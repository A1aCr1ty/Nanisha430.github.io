<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-csapp-ShellLab实验" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/07/csapp-ShellLab%E5%AE%9E%E9%AA%8C/" class="article-date">
  <time datetime="2022-12-07T03:18:20.000Z" itemprop="datePublished">2022-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/07/csapp-ShellLab%E5%AE%9E%E9%AA%8C/">csapp:ShellLab实验</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本目标"><a href="#基本目标" class="headerlink" title="基本目标"></a>基本目标</h2><p>实验一个unix shell 程序，具有quit ，jobs，fg ，bg，和正常命令的功能。</p>
<h2 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h2><p>用来接受parse结果的数据结构userinput_t:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USERINPUT_STRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// the job type of current user input</span></span><br><span class="line">    <span class="type">job_t</span> type;</span><br><span class="line">    <span class="comment">// the count of arguments</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    <span class="comment">// the pointers to buffer</span></span><br><span class="line">    <span class="type">char</span> *(argv[MAX_ARG_COUNT]);</span><br><span class="line">    <span class="comment">// the parsed buffer</span></span><br><span class="line">    <span class="type">char</span> buffer[MAX_ARG_COUNT][MAX_LENGTH_USERINPUT];</span><br><span class="line">    <span class="comment">// the raw char pointer</span></span><br><span class="line">    <span class="type">char</span> *raw;</span><br><span class="line">&#125; <span class="type">userinput_t</span>;</span><br></pre></td></tr></table></figure>

<p>用来保存整个程序正在执行的任务的列表 job_list:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">JOB_TASK_STRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">job_state_t</span> state;</span><br><span class="line">    <span class="type">char</span> argstr[MAX_LENGTH_USERINPUT];</span><br><span class="line">&#125; <span class="type">job_task_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM_JOBS (64)</span></span><br><span class="line"><span class="type">job_task_t</span> job_list[MAX_NUM_JOBS];</span><br></pre></td></tr></table></figure>

<p>用户输入的命令的类型job_t：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    EMPTY,</span><br><span class="line">    <span class="comment">// built-in command</span></span><br><span class="line">    <span class="comment">// &quot;quit&quot; to terminate shell</span></span><br><span class="line">    <span class="comment">// &quot;jobs&quot; to list all background jobs</span></span><br><span class="line">    <span class="comment">// &quot;bg &lt;pid&gt;&quot; to restart job in background by sending SIGCONT</span></span><br><span class="line">    <span class="comment">// &quot;fg &lt;pid&gt;&quot; to restart job in foreground by sending SIGCONT</span></span><br><span class="line">    BUILTIN_QUIT,</span><br><span class="line">    BUILTIN_JOBS,</span><br><span class="line">    BUILTIN_FGCONT,</span><br><span class="line">    BUILTIN_BGCONT,</span><br><span class="line">    <span class="comment">// foreground job taking the control flow</span></span><br><span class="line">    <span class="comment">// shell should wait for forground job to finish</span></span><br><span class="line">    FOREGROUND_JOB,</span><br><span class="line">    <span class="comment">// background job leaving the control flow</span></span><br><span class="line">    <span class="comment">// background job are ending with &#x27;&amp;&#x27;, e.g.,</span></span><br><span class="line">    <span class="comment">// &gt; /bin/sleep 5 &amp;</span></span><br><span class="line">    <span class="comment">// shell should NOT wait for background job to finish</span></span><br><span class="line">    BACKGROUND_JOB</span><br><span class="line">&#125; <span class="type">job_t</span>;</span><br></pre></td></tr></table></figure>

<p>程序中任务的状态job_state_t:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UNKNOWN,</span><br><span class="line">    FG_RUNNING,</span><br><span class="line">    BG_RUNNING,</span><br><span class="line">    STOPPED,</span><br><span class="line">&#125; <span class="type">job_state_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先要parse_userinput,将用户输入的命令进行分析，得到我们想要的参数和结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse_userinput</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *input, </span></span><br><span class="line"><span class="params">    <span class="type">userinput_t</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;Failed to fetch space for user input parsing result\n&quot;</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// empty as default</span></span><br><span class="line">    result-&gt;type = EMPTY;</span><br><span class="line">    result-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    result-&gt;raw = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(result-&gt;argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(result-&gt;argv));</span><br><span class="line">    <span class="built_in">memset</span>(result-&gt;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(result-&gt;buffer));</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span> || *input == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result-&gt;raw = (<span class="type">char</span> *)input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the previous char</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first we count the size of argv</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LENGTH_USERINPUT; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;\0&#x27;</span> || input[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (p == <span class="number">-1</span> || input[p] == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;argc += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the current parsed argument char</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LENGTH_USERINPUT; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((input[i] == <span class="string">&#x27; &#x27;</span> || input[i] == <span class="string">&#x27;\0&#x27;</span> || input[i] == <span class="string">&#x27;\n&#x27;</span>) &amp;&amp; </span><br><span class="line">            (p != <span class="number">-1</span> || input[p] != <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(result-&gt;buffer[j], &amp;input[w], i - w);</span><br><span class="line">            result-&gt;buffer[j][i - w] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            result-&gt;argv[j] = result-&gt;buffer[j];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// reset to next word</span></span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (p == <span class="number">-1</span> || input[p] == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            w = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// go to next input char</span></span><br><span class="line">        p = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;\0&#x27;</span> || input[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;argc &gt;= <span class="number">2</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(result-&gt;buffer[result-&gt;argc - <span class="number">1</span>], <span class="string">&quot;&amp;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result-&gt;type = BACKGROUND_JOB;</span><br><span class="line">        result-&gt;argv[result-&gt;argc - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        result-&gt;argc -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result-&gt;argc &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result-&gt;type = FOREGROUND_JOB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_QUIT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_JOBS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result-&gt;argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_FGCONT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_BGCONT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次就是evaluate,根据不同的命令执行不同的操作，quit退出shell，jobs打印正在运行的job，fg <pid>将某个任务转换成前台任务，bg <pid>将某个任务转换成后台任务，还有其他系统自身前台后台执行和后台执行的命令。</pid></pid></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evaluate</span><span class="params">(<span class="type">userinput_t</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (input-&gt;type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_QUIT:</span><br><span class="line">        <span class="built_in">printf</span>(YELLOWSTR(<span class="string">&quot;Shell terminating ...\n&quot;</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_JOBS:</span><br><span class="line">        job_print();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_FGCONT:</span><br><span class="line">        job_fg(input);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_BGCONT:</span><br><span class="line">        job_bg(input);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FOREGROUND_JOB:</span><br><span class="line">    <span class="keyword">case</span> BACKGROUND_JOB:</span><br><span class="line">        child_process(input);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行命令中是要创建子进程的过程，所有进程被创建后都要被加入到全局变量job_list中，这就涉及到了一个race condition的问题了。正常的流程是创建子进程-&gt;加入job_list-&gt;子进程结束-&gt;移出job_list,总之加入子进程要在移除job_list之前，但是在并发编程中谁也无法保证这个顺序，所以我们需要用信号量的机制来保证进程同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">child_process</span><span class="params">(<span class="type">userinput_t</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block before fork to eliminate the race condition between</span></span><br><span class="line">    <span class="comment">// parent (shell) and the handler threads on the </span></span><br><span class="line">    <span class="comment">// global resource -- job list add/delete</span></span><br><span class="line">    <span class="comment">// handler should delete the job from the list after it&#x27;s added</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// new created child process will inherit the signal</span></span><br><span class="line">        <span class="comment">// pending vector, blocking vector from parent.</span></span><br><span class="line">        <span class="comment">// unblock and reset in case further execve will fork</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        pid = getpid();</span><br><span class="line">        setpgid(pid, pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do not trigger copy on write here</span></span><br><span class="line">        <span class="keyword">if</span> (execve(input-&gt;argv[<span class="number">0</span>], input-&gt;argv, envp) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;failed to execute %s\n&quot;</span>), input-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input-&gt;type == FOREGROUND_JOB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// critical section</span></span><br><span class="line">            <span class="comment">// when SIGCHLD is blocked</span></span><br><span class="line">            <span class="comment">// the code in this section is executed before handler</span></span><br><span class="line">            job_add(pid, FG_RUNNING, input-&gt;raw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fg_pid is also a critical global variable</span></span><br><span class="line">            fg_reaped = <span class="number">0</span>;</span><br><span class="line">            fg_pid = pid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for hanlder being invoked</span></span><br><span class="line">            <span class="keyword">while</span> (fg_reaped == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// RACE CONDITION: handler already invoked.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// sleep(1) -- correct, but waste CPU time</span></span><br><span class="line">                <span class="comment">// pause() -- save CPU time, but RACE CONDITION</span></span><br><span class="line">                sigsuspend(&amp;prev);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// SIGCHLD is still blocked here</span></span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input-&gt;type == BACKGROUND_JOB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// background job: just go to next iteration</span></span><br><span class="line">            <span class="comment">// Question: what will happen if background job has</span></span><br><span class="line">            <span class="comment">// STDOUT to terminal/monitor?</span></span><br><span class="line">            job_add(pid, BG_RUNNING, input-&gt;raw);</span><br><span class="line">            assert(fg_reaped = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unblock -- recover the previous signal block vector</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子进程创建之前我们首先要注册信号并且进行阻塞操作;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	register_sighandler(SIGCHLD, sigchld_handler,   SA_RESTART);   <span class="comment">//子进程结束会发sigchld</span></span><br><span class="line">	register_sighandler(SIGINT,  sigproxy_handler,  SA_RESTART);   <span class="comment">//ctrl+c 发sigint</span></span><br><span class="line">    register_sighandler(SIGTSTP, sigproxy_handler,  SA_RESTART);   <span class="comment">//ctrl+z 发sigtstp</span></span><br><span class="line">....</span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br></pre></td></tr></table></figure>

<p>相关信号的处理函数，当有信号发生时就会执行信号的处理函数，我们阻塞信号的目的就是让add_job()在信号处理函数之前执行，一般job_delete和job_state函数在信号处理函数中被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// async-signal-safe system functions may set errno</span></span><br><span class="line">    <span class="comment">// when return with error. E.g., waitpid.</span></span><br><span class="line">    <span class="comment">// So we need to save errno on stack and restore it.</span></span><br><span class="line">    <span class="type">int</span> _errno = errno;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid(-1) -- match any process</span></span><br><span class="line">    <span class="comment">// other child processes may terminate</span></span><br><span class="line">    <span class="comment">// but at most one SIGCHLD would be pending</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// waitpid - wait for state change of a child:</span></span><br><span class="line">    <span class="comment">//  1.  child terminated</span></span><br><span class="line">    <span class="comment">//  2.  child stopped by a signal (SIGTSTP)</span></span><br><span class="line">    <span class="comment">//  3.  child resumed by a signal (CONTINUE)</span></span><br><span class="line">    <span class="comment">// Wait-No-Hang flag to avoid wait and return immediately</span></span><br><span class="line">    <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG | WCONTINUED);</span><br><span class="line">    <span class="keyword">while</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// when this handler is invoked,</span></span><br><span class="line">        <span class="comment">// SIGCHLD is unblocked.</span></span><br><span class="line">        <span class="comment">// so it&#x27;s safe to operate on global resource</span></span><br><span class="line">        <span class="keyword">if</span> (pid == fg_pid)</span><br><span class="line">        &#123;</span><br><span class="line">            fg_reaped = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was exited normally: exit() or return from main()</span></span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] exits normally\n&quot;</span>), pid);</span><br><span class="line">            job_delete(pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was terminated by signal: SIGINT</span></span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] is terminated by %u\n&quot;</span>), pid, WTERMSIG(status));</span><br><span class="line">            job_delete(pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was stopped by signal</span></span><br><span class="line">            <span class="comment">// must unset action SA_NOCLDSTOP</span></span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] is stopped by %u\n&quot;</span>), pid, WSTOPSIG(status));</span><br><span class="line">            job_state(pid, STOPPED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was resumed by delivery of SIGCONT</span></span><br><span class="line">            <span class="comment">// must unset action SA_NOCLDSTOP</span></span><br><span class="line">            <span class="type">job_state_t</span> jstate = job_get_state(pid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(jstate == STOPPED)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st_bgfg = <span class="number">1</span>)</span><br><span class="line">                    job_state(pid,BG_RUNNING); </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    job_state(pid,FG_RUNNING);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] is resumed by SIGCONT\n&quot;</span>), pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delivery of SIGCHLD is blocked during handler execution</span></span><br><span class="line">        <span class="comment">// unless set SA_NODEFER in sigaction()</span></span><br><span class="line">        <span class="comment">// If one SIGCHLD is generated again, it&#x27;s marked as pending</span></span><br><span class="line">        <span class="comment">// and would be delivered **WHEN HANDLER RETURNS**</span></span><br><span class="line">        pid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG | WCONTINUED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If another child exits here, send SIGCHLD to shell</span></span><br><span class="line">    <span class="comment">// shell would have at least one pending SIGCHLD</span></span><br><span class="line">    <span class="comment">// so there would be at least another handler invocation to reap.</span></span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore errno</span></span><br><span class="line">    errno = _errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT/SIGTSTP should be invoked only after fg_pid is valid</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigproxy_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _errno = errno;</span><br><span class="line">    <span class="comment">// proxy SIGINT/SIGTSTP to foreground process group:</span></span><br><span class="line">    <span class="comment">// FG job may create child processes.</span></span><br><span class="line">    <span class="comment">// These processes are all grouped by FG job pid</span></span><br><span class="line">    <span class="keyword">if</span> (fg_pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// after the child terminated by SIGINT or stopped by SIGINT</span></span><br><span class="line">        <span class="comment">// waitpid will capture</span></span><br><span class="line">        killpg(fg_pid, sig);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = _errno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于wait,一个子进程的状态发生了变化，主进程需要知道，就是通过wait得到的，比如子进程死亡，主进程通过sigchld知道子进程死亡，但是不知道子进程是因为什么原因死亡的，是正常结束，还是ctrl+c，还是exit ，这些都可以通过wait系统调用得到。</p>
<p>前台进程会将主进程阻塞，直到进程结束或这暂停才会回复：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (input-&gt;type == FOREGROUND_JOB)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">// critical section</span></span><br><span class="line">           <span class="comment">// when SIGCHLD is blocked</span></span><br><span class="line">           <span class="comment">// the code in this section is executed before handler</span></span><br><span class="line">           job_add(pid, FG_RUNNING, input-&gt;raw);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// fg_pid is also a critical global variable</span></span><br><span class="line">           fg_reaped = <span class="number">0</span>;</span><br><span class="line">           fg_pid = pid;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// wait for hanlder being invoked</span></span><br><span class="line">           <span class="keyword">while</span> (fg_reaped == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">// RACE CONDITION: handler already invoked.</span></span><br><span class="line"></span><br><span class="line">               <span class="comment">// sleep(1) -- correct, but waste CPU time</span></span><br><span class="line">               <span class="comment">// pause() -- save CPU time, but RACE CONDITION</span></span><br><span class="line">               sigsuspend(&amp;prev);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// SIGCHLD is still blocked here</span></span><br><span class="line">               sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>最后任务状态转化：</p>
<p><img src="/2022/12/07/csapp-ShellLab%E5%AE%9E%E9%AA%8C/image-20221208150558589.png" alt="image-20221208150558589"></p>
<p>主要实现，这两个函数可以合成一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_bg</span><span class="params">(<span class="type">userinput_t</span> *input)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(input-&gt;type == BUILTIN_BGCONT)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">        sigemptyset(&amp;mask);</span><br><span class="line">        sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">        sigaddset(&amp;mask, SIGINT);</span><br><span class="line">        sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//block</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *btin = input-&gt;argv[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *id = input-&gt;argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = (<span class="type">pid_t</span>)atoi(id); </span><br><span class="line">        st_bgfg =<span class="number">1</span>;</span><br><span class="line">        killpg(pid,SIGCONT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unblock -- recover the previous signal block vector</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_fg</span><span class="params">(<span class="type">userinput_t</span> *input)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input-&gt;type == BUILTIN_FGCONT)&#123;</span><br><span class="line">        <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">        sigemptyset(&amp;mask);</span><br><span class="line">        sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">        sigaddset(&amp;mask, SIGINT);</span><br><span class="line">        sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//block</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *btin = input-&gt;argv[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *id = input-&gt;argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = (<span class="type">pid_t</span>)atoi(id); </span><br><span class="line"></span><br><span class="line">        fg_pid = pid;</span><br><span class="line">        fg_reaped = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">job_state_t</span> jstate =  job_get_state(pid);</span><br><span class="line">        <span class="keyword">if</span>(jstate == STOPPED)&#123;</span><br><span class="line">            st_bgfg = <span class="number">2</span>;</span><br><span class="line">            killpg(pid,SIGCONT);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(jstate == BG_RUNNING)&#123;</span><br><span class="line">            job_state(pid,FG_RUNNING);</span><br><span class="line">            <span class="keyword">while</span>(fg_reaped == <span class="number">0</span>)&#123;</span><br><span class="line">                sigsuspend(&amp;prev);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unblock -- recover the previous signal block vector</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总体源代码"><a href="#总体源代码" class="headerlink" title="总体源代码"></a>总体源代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _XOPEN_SOURCE 600</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// input line on stdin from user</span></span><br><span class="line"><span class="comment">// the input line should be parsed</span></span><br><span class="line"><span class="comment">// and shell invokes corresponding actions</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH_USERINPUT (128)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ARG_COUNT (32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDSTR(STR)     <span class="string">&quot;\033[31;1m&quot;</span>STR<span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREENSTR(STR)   <span class="string">&quot;\033[32;1m&quot;</span>STR<span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOWSTR(STR)  <span class="string">&quot;\033[33;1m&quot;</span>STR<span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUESTR(STR)    <span class="string">&quot;\033[34;1m&quot;</span>STR<span class="string">&quot;\033[0m&quot;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">safe_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    EMPTY,</span><br><span class="line">    <span class="comment">// built-in command</span></span><br><span class="line">    <span class="comment">// &quot;quit&quot; to terminate shell</span></span><br><span class="line">    <span class="comment">// &quot;jobs&quot; to list all background jobs</span></span><br><span class="line">    <span class="comment">// &quot;bg &lt;pid&gt;&quot; to restart job in background by sending SIGCONT</span></span><br><span class="line">    <span class="comment">// &quot;fg &lt;pid&gt;&quot; to restart job in foreground by sending SIGCONT</span></span><br><span class="line">    BUILTIN_QUIT,</span><br><span class="line">    BUILTIN_JOBS,</span><br><span class="line">    BUILTIN_FGCONT,</span><br><span class="line">    BUILTIN_BGCONT,</span><br><span class="line">    <span class="comment">// foreground job taking the control flow</span></span><br><span class="line">    <span class="comment">// shell should wait for forground job to finish</span></span><br><span class="line">    FOREGROUND_JOB,</span><br><span class="line">    <span class="comment">// background job leaving the control flow</span></span><br><span class="line">    <span class="comment">// background job are ending with &#x27;&amp;&#x27;, e.g.,</span></span><br><span class="line">    <span class="comment">// &gt; /bin/sleep 5 &amp;</span></span><br><span class="line">    <span class="comment">// shell should NOT wait for background job to finish</span></span><br><span class="line">    BACKGROUND_JOB</span><br><span class="line">&#125; <span class="type">job_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">USERINPUT_STRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// the job type of current user input</span></span><br><span class="line">    <span class="type">job_t</span> type;</span><br><span class="line">    <span class="comment">// the count of arguments</span></span><br><span class="line">    <span class="type">int</span> argc;</span><br><span class="line">    <span class="comment">// the pointers to buffer</span></span><br><span class="line">    <span class="type">char</span> *(argv[MAX_ARG_COUNT]);</span><br><span class="line">    <span class="comment">// the parsed buffer</span></span><br><span class="line">    <span class="type">char</span> buffer[MAX_ARG_COUNT][MAX_LENGTH_USERINPUT];</span><br><span class="line">    <span class="comment">// the raw char pointer</span></span><br><span class="line">    <span class="type">char</span> *raw;</span><br><span class="line">&#125; <span class="type">userinput_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    UNKNOWN,</span><br><span class="line">    FG_RUNNING,</span><br><span class="line">    BG_RUNNING,</span><br><span class="line">    STOPPED,</span><br><span class="line">&#125; <span class="type">job_state_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *JOB_STATE_STR[<span class="number">4</span>] = &#123; <span class="string">&quot;UK&quot;</span>, <span class="string">&quot;FG&quot;</span>, <span class="string">&quot;BG&quot;</span>, <span class="string">&quot;ST&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">JOB_TASK_STRUCT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">job_state_t</span> state;</span><br><span class="line">    <span class="type">char</span> argstr[MAX_LENGTH_USERINPUT];</span><br><span class="line">&#125; <span class="type">job_task_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NUM_JOBS (64)</span></span><br><span class="line"><span class="type">job_task_t</span> job_list[MAX_NUM_JOBS];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">job_add</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">job_state_t</span> state, <span class="type">char</span> *argstr)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">job_delete</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_print</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">job_state</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">job_state_t</span> state)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse_userinput</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *input,</span></span><br><span class="line"><span class="params">    <span class="type">userinput_t</span> *result)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evaluate</span><span class="params">(<span class="type">userinput_t</span> *input)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler for SIGCHLD when a child process terminates</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handler for SIGINT sent by Ctrl-C or SIGTSTP sent by Ctrl-Z</span></span><br><span class="line"><span class="comment">// when Ctrl-C, the signal should be sent to foreground job group</span></span><br><span class="line"><span class="comment">// i.e., child process may create child process</span></span><br><span class="line"><span class="comment">// when Ctrl-Z, the signal should be sent to foreground job group</span></span><br><span class="line"><span class="comment">// i.e., child process may create child process</span></span><br><span class="line"><span class="comment">// and shell process &amp; other background processes </span></span><br><span class="line"><span class="comment">// should not be interrupted</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigproxy_handler</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_bg</span><span class="params">(<span class="type">userinput_t</span> *input)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_fg</span><span class="params">(<span class="type">userinput_t</span> *input)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">job_state_t</span> <span class="title function_">job_get_state</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> *<span class="title function_">register_sighandler</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> sig, <span class="type">sighandler_t</span> *handler, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>, <span class="title">old_action</span>;</span></span><br><span class="line">    action.sa_handler = handler;</span><br><span class="line">    sigemptyset(&amp;action.sa_mask);</span><br><span class="line">    action.sa_flags = flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sigaction(sig, &amp;action, &amp;old_action) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;Signal error\n&quot;</span>, <span class="number">13</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_action.sa_handler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  flag indicating if sigchld has been invoked</span></span><br><span class="line"><span class="comment">    to wait for child process zombies.</span></span><br><span class="line"><span class="comment">    -------------------------------------------</span></span><br><span class="line"><span class="comment">    Use volatile to keep the atomic flag inside memory</span></span><br><span class="line"><span class="comment">    R/W global variables may invole &gt;= 1 instructions,</span></span><br><span class="line"><span class="comment">    so the operation is not atomic.</span></span><br><span class="line"><span class="comment">    Use sig_atomic_t to gaurantee atomicity:</span></span><br><span class="line"><span class="comment">    Write it in main flow and read it in handler flow; Or:</span></span><br><span class="line"><span class="comment">    Read it in main flow and write it in handler flow.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> fg_reaped = <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">sig_atomic_t</span> fg_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> st_bgfg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">userinput_t</span> input;</span><br><span class="line">    <span class="type">char</span> input_chars[MAX_LENGTH_USERINPUT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register handlers for signals</span></span><br><span class="line">    <span class="comment">// with this, this program can only run on *unix</span></span><br><span class="line">    register_sighandler(SIGCHLD, sigchld_handler,   SA_RESTART);</span><br><span class="line">    register_sighandler(SIGINT,  sigproxy_handler,  SA_RESTART);</span><br><span class="line">    register_sighandler(SIGTSTP, sigproxy_handler,  SA_RESTART);</span><br><span class="line"></span><br><span class="line">    job_init();</span><br><span class="line">    <span class="type">pid_t</span> shell_pid = getpid();</span><br><span class="line">    st_bgfg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(GREENSTR(<span class="string">&quot;[%d] &gt; &quot;</span>), shell_pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read user input</span></span><br><span class="line">        fgets(input_chars, MAX_LENGTH_USERINPUT, <span class="built_in">stdin</span>);</span><br><span class="line">        parse_userinput(input_chars, &amp;input);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input.type == EMPTY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            evaluate(&amp;input);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">child_process</span><span class="params">(<span class="type">userinput_t</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *envp[] = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block before fork to eliminate the race condition between</span></span><br><span class="line">    <span class="comment">// parent (shell) and the handler threads on the </span></span><br><span class="line">    <span class="comment">// global resource -- job list add/delete</span></span><br><span class="line">    <span class="comment">// handler should delete the job from the list after it&#x27;s added</span></span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// new created child process will inherit the signal</span></span><br><span class="line">        <span class="comment">// pending vector, blocking vector from parent.</span></span><br><span class="line">        <span class="comment">// unblock and reset in case further execve will fork</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        pid = getpid();</span><br><span class="line">        setpgid(pid, pid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do not trigger copy on write here</span></span><br><span class="line">        <span class="keyword">if</span> (execve(input-&gt;argv[<span class="number">0</span>], input-&gt;argv, envp) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;failed to execute %s\n&quot;</span>), input-&gt;argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input-&gt;type == FOREGROUND_JOB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// critical section</span></span><br><span class="line">            <span class="comment">// when SIGCHLD is blocked</span></span><br><span class="line">            <span class="comment">// the code in this section is executed before handler</span></span><br><span class="line">            job_add(pid, FG_RUNNING, input-&gt;raw);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fg_pid is also a critical global variable</span></span><br><span class="line">            fg_reaped = <span class="number">0</span>;</span><br><span class="line">            fg_pid = pid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// wait for hanlder being invoked</span></span><br><span class="line">            <span class="keyword">while</span> (fg_reaped == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// RACE CONDITION: handler already invoked.</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// sleep(1) -- correct, but waste CPU time</span></span><br><span class="line">                <span class="comment">// pause() -- save CPU time, but RACE CONDITION</span></span><br><span class="line">                sigsuspend(&amp;prev);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// SIGCHLD is still blocked here</span></span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input-&gt;type == BACKGROUND_JOB)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// background job: just go to next iteration</span></span><br><span class="line">            <span class="comment">// Question: what will happen if background job has</span></span><br><span class="line">            <span class="comment">// STDOUT to terminal/monitor?</span></span><br><span class="line">            job_add(pid, BG_RUNNING, input-&gt;raw);</span><br><span class="line">            assert(fg_reaped = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unblock -- recover the previous signal block vector</span></span><br><span class="line">            sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">evaluate</span><span class="params">(<span class="type">userinput_t</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (input-&gt;type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_QUIT:</span><br><span class="line">        <span class="built_in">printf</span>(YELLOWSTR(<span class="string">&quot;Shell terminating ...\n&quot;</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_JOBS:</span><br><span class="line">        job_print();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_FGCONT:</span><br><span class="line">        job_fg(input);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BUILTIN_BGCONT:</span><br><span class="line">        job_bg(input);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FOREGROUND_JOB:</span><br><span class="line">    <span class="keyword">case</span> BACKGROUND_JOB:</span><br><span class="line">        child_process(input);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">job_state_t</span> <span class="title function_">job_get_state</span><span class="params">(<span class="type">pid_t</span> pid)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MAX_NUM_JOBS;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(job_list[i].pid==pid)&#123;</span><br><span class="line">            <span class="keyword">return</span> job_list[i].state;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_bg</span><span class="params">(<span class="type">userinput_t</span> *input)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(input-&gt;type == BUILTIN_BGCONT)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">        sigemptyset(&amp;mask);</span><br><span class="line">        sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">        sigaddset(&amp;mask, SIGINT);</span><br><span class="line">        sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//block</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">        </span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *btin = input-&gt;argv[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *id = input-&gt;argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = (<span class="type">pid_t</span>)atoi(id); </span><br><span class="line">        st_bgfg =<span class="number">1</span>;</span><br><span class="line">        killpg(pid,SIGCONT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unblock -- recover the previous signal block vector</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_fg</span><span class="params">(<span class="type">userinput_t</span> *input)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(input-&gt;type == BUILTIN_FGCONT)&#123;</span><br><span class="line">        <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">        sigemptyset(&amp;mask);</span><br><span class="line">        sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line">        sigaddset(&amp;mask, SIGINT);</span><br><span class="line">        sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//block</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *btin = input-&gt;argv[<span class="number">0</span>];</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *id = input-&gt;argv[<span class="number">1</span>];</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = (<span class="type">pid_t</span>)atoi(id); </span><br><span class="line"></span><br><span class="line">        fg_pid = pid;</span><br><span class="line">        fg_reaped = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">job_state_t</span> jstate =  job_get_state(pid);</span><br><span class="line">        <span class="keyword">if</span>(jstate == STOPPED)&#123;</span><br><span class="line">            st_bgfg = <span class="number">2</span>;</span><br><span class="line">            killpg(pid,SIGCONT);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(jstate == BG_RUNNING)&#123;</span><br><span class="line">            job_state(pid,FG_RUNNING);</span><br><span class="line">            <span class="keyword">while</span>(fg_reaped == <span class="number">0</span>)&#123;</span><br><span class="line">                sigsuspend(&amp;prev);</span><br><span class="line">                sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// unblock -- recover the previous signal block vector</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGCHLD is sent to parent whenever one child terminates</span></span><br><span class="line"><span class="comment">// By default the signal is ignored so the child becomes zombie.</span></span><br><span class="line"><span class="comment">// SIGCHLD handler may also be invoked when receive</span></span><br><span class="line"><span class="comment">//      SIGTSTP, SIGSTOP, SIGTTIN, SIGTTOU to stop</span></span><br><span class="line"><span class="comment">//      SIGCONT to resume</span></span><br><span class="line"><span class="comment">// But if set signal action SA_NOCLDSTOP, will ignore</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// async-signal-safe system functions may set errno</span></span><br><span class="line">    <span class="comment">// when return with error. E.g., waitpid.</span></span><br><span class="line">    <span class="comment">// So we need to save errno on stack and restore it.</span></span><br><span class="line">    <span class="type">int</span> _errno = errno;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    </span><br><span class="line">    <span class="type">sigset_t</span> mask, prev;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    sigaddset(&amp;mask, SIGINT);</span><br><span class="line">    sigaddset(&amp;mask, SIGTSTP);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// waitpid(-1) -- match any process</span></span><br><span class="line">    <span class="comment">// other child processes may terminate</span></span><br><span class="line">    <span class="comment">// but at most one SIGCHLD would be pending</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// waitpid - wait for state change of a child:</span></span><br><span class="line">    <span class="comment">//  1.  child terminated</span></span><br><span class="line">    <span class="comment">//  2.  child stopped by a signal (SIGTSTP)</span></span><br><span class="line">    <span class="comment">//  3.  child resumed by a signal (CONTINUE)</span></span><br><span class="line">    <span class="comment">// Wait-No-Hang flag to avoid wait and return immediately</span></span><br><span class="line">    <span class="type">pid_t</span> pid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG | WCONTINUED);</span><br><span class="line">    <span class="keyword">while</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// when this handler is invoked,</span></span><br><span class="line">        <span class="comment">// SIGCHLD is unblocked.</span></span><br><span class="line">        <span class="comment">// so it&#x27;s safe to operate on global resource</span></span><br><span class="line">        <span class="keyword">if</span> (pid == fg_pid)</span><br><span class="line">        &#123;</span><br><span class="line">            fg_reaped = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was exited normally: exit() or return from main()</span></span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] exits normally\n&quot;</span>), pid);</span><br><span class="line">            job_delete(pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was terminated by signal: SIGINT</span></span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] is terminated by %u\n&quot;</span>), pid, WTERMSIG(status));</span><br><span class="line">            job_delete(pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFSTOPPED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was stopped by signal</span></span><br><span class="line">            <span class="comment">// must unset action SA_NOCLDSTOP</span></span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] is stopped by %u\n&quot;</span>), pid, WSTOPSIG(status));</span><br><span class="line">            job_state(pid, STOPPED);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WIFCONTINUED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// child was resumed by delivery of SIGCONT</span></span><br><span class="line">            <span class="comment">// must unset action SA_NOCLDSTOP</span></span><br><span class="line">            <span class="type">job_state_t</span> jstate = job_get_state(pid);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(jstate == STOPPED)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st_bgfg = <span class="number">1</span>)</span><br><span class="line">                    job_state(pid,BG_RUNNING); </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    job_state(pid,FG_RUNNING);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            safe_printf(BLUESTR(<span class="string">&quot;[%u] is resumed by SIGCONT\n&quot;</span>), pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Delivery of SIGCHLD is blocked during handler execution</span></span><br><span class="line">        <span class="comment">// unless set SA_NODEFER in sigaction()</span></span><br><span class="line">        <span class="comment">// If one SIGCHLD is generated again, it&#x27;s marked as pending</span></span><br><span class="line">        <span class="comment">// and would be delivered **WHEN HANDLER RETURNS**</span></span><br><span class="line">        pid = waitpid(<span class="number">-1</span>, &amp;status, WUNTRACED | WNOHANG | WCONTINUED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If another child exits here, send SIGCHLD to shell</span></span><br><span class="line">    <span class="comment">// shell would have at least one pending SIGCHLD</span></span><br><span class="line">    <span class="comment">// so there would be at least another handler invocation to reap.</span></span><br><span class="line"></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore errno</span></span><br><span class="line">    errno = _errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIGINT/SIGTSTP should be invoked only after fg_pid is valid</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">sigproxy_handler</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> _errno = errno;</span><br><span class="line">    <span class="comment">// proxy SIGINT/SIGTSTP to foreground process group:</span></span><br><span class="line">    <span class="comment">// FG job may create child processes.</span></span><br><span class="line">    <span class="comment">// These processes are all grouped by FG job pid</span></span><br><span class="line">    <span class="keyword">if</span> (fg_pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// after the child terminated by SIGINT or stopped by SIGINT</span></span><br><span class="line">        <span class="comment">// waitpid will capture</span></span><br><span class="line">        killpg(fg_pid, sig);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = _errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the job list</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM_JOBS; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        job_list[i].state = UNKNOWN;</span><br><span class="line">        job_list[i].pid = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(job_list[i].argstr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(job_list[i].argstr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert a new pid into background job list</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">job_add</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">job_state_t</span> state, <span class="type">char</span> *argstr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM_JOBS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (job_list[i].state == UNKNOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// insert to this job</span></span><br><span class="line">            job_list[i].pid = pid;</span><br><span class="line">            job_list[i].state = state;</span><br><span class="line">            <span class="built_in">strcpy</span>(job_list[i].argstr, argstr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;job_add::no free slot for new job\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete an existing pid from background job list</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">job_delete</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM_JOBS; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (job_list[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            job_list[i].pid = <span class="number">0</span>;</span><br><span class="line">            job_list[i].state = UNKNOWN;</span><br><span class="line">            <span class="built_in">memset</span>(job_list[i].argstr, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(job_list[i].argstr));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;job_delete::pid &#123;%d&#125; not found from job list\n&quot;</span>), pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the state of an existing pid from job list</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">job_state</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">job_state_t</span> state)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM_JOBS; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (job_list[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            job_list[i].state = state;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;job_state::pid &#123;%d&#125; not found from job list\n&quot;</span>), pid);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the job list content</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">job_print</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_NUM_JOBS; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (job_list[i].state == UNKNOWN)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]\t%s\t%s\n&quot;</span>,</span><br><span class="line">            job_list[i].pid,</span><br><span class="line">            JOB_STATE_STR[job_list[i].state],</span><br><span class="line">            job_list[i].argstr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse the user input</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">parse_userinput</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *input, </span></span><br><span class="line"><span class="params">    <span class="type">userinput_t</span> *result)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(REDSTR(<span class="string">&quot;Failed to fetch space for user input parsing result\n&quot;</span>));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// empty as default</span></span><br><span class="line">    result-&gt;type = EMPTY;</span><br><span class="line">    result-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    result-&gt;raw = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(result-&gt;argv, <span class="number">0</span>, <span class="keyword">sizeof</span>(result-&gt;argv));</span><br><span class="line">    <span class="built_in">memset</span>(result-&gt;buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(result-&gt;buffer));</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span> || *input == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result-&gt;raw = (<span class="type">char</span> *)input;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the previous char</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// first we count the size of argv</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LENGTH_USERINPUT; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;\0&#x27;</span> || input[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (input[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (p == <span class="number">-1</span> || input[p] == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;argc += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the current parsed argument char</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LENGTH_USERINPUT; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((input[i] == <span class="string">&#x27; &#x27;</span> || input[i] == <span class="string">&#x27;\0&#x27;</span> || input[i] == <span class="string">&#x27;\n&#x27;</span>) &amp;&amp; </span><br><span class="line">            (p != <span class="number">-1</span> || input[p] != <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">strncpy</span>(result-&gt;buffer[j], &amp;input[w], i - w);</span><br><span class="line">            result-&gt;buffer[j][i - w] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            result-&gt;argv[j] = result-&gt;buffer[j];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// reset to next word</span></span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (input[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; (p == <span class="number">-1</span> || input[p] == <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            w = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// go to next input char</span></span><br><span class="line">        p = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (input[i] == <span class="string">&#x27;\0&#x27;</span> || input[i] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;argc &gt;= <span class="number">2</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strcmp</span>(result-&gt;buffer[result-&gt;argc - <span class="number">1</span>], <span class="string">&quot;&amp;&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result-&gt;type = BACKGROUND_JOB;</span><br><span class="line">        result-&gt;argv[result-&gt;argc - <span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        result-&gt;argc -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result-&gt;argc &gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result-&gt;type = FOREGROUND_JOB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_QUIT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_JOBS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result-&gt;argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_FGCONT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(result-&gt;buffer[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result-&gt;type = BUILTIN_BGCONT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async-signal-safe printf: support %s and %u only</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">convert_unsigned</span><span class="params">(<span class="type">unsigned</span> u, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>, is_leading_zero = <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> b = <span class="number">1000000000</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t = u / b;</span><br><span class="line">        u = u - t * b;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span> || b == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            is_leading_zero = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="number">0</span> || is_leading_zero == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[len] = t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            len += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b = b / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">safe_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list argp;</span><br><span class="line">    va_start(argp, fmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 pointers:</span></span><br><span class="line">    <span class="comment">// i for scanned in format string</span></span><br><span class="line">    <span class="comment">// j for written in stdout</span></span><br><span class="line">    <span class="comment">// write for: (1) string in fmt; (2) escape in fmt; in each loop</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fmt[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Handle format characters</span></span><br><span class="line">        <span class="keyword">if</span> (fmt[i] == <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (fmt[i + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// string format</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                <span class="comment">// write previous string in fmt</span></span><br><span class="line">                write(STDOUT_FILENO, &amp;fmt[start], i - start);</span><br><span class="line">                <span class="comment">// write string in arg</span></span><br><span class="line">                <span class="type">char</span> *str = va_arg(argp, <span class="type">char</span> *);</span><br><span class="line">                len = <span class="built_in">strlen</span>(str);</span><br><span class="line">                write(STDOUT_FILENO, str, len);</span><br><span class="line">                <span class="comment">// reset pointer</span></span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                j += len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unsigned format</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="comment">// write previous string in fmt</span></span><br><span class="line">                write(STDOUT_FILENO, &amp;fmt[start], i - start);</span><br><span class="line">                <span class="comment">// write unsigned in arg</span></span><br><span class="line">                <span class="type">char</span> buf[<span class="number">11</span>];</span><br><span class="line">                <span class="type">unsigned</span> u = va_arg(argp, <span class="type">unsigned</span>);</span><br><span class="line">                len = convert_unsigned(u, buf);</span><br><span class="line">                write(STDOUT_FILENO, buf, len);</span><br><span class="line">                <span class="comment">// reset pointer</span></span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                j += len;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// like continue</span></span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print the tailing strings</span></span><br><span class="line">    <span class="keyword">if</span> (i - start &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(STDOUT_FILENO, &amp;fmt[start], i - start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(argp);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/07/csapp-ShellLab%E5%AE%9E%E9%AA%8C/" data-id="clbeqlosg0000lgmjholcastv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-线程同步机制的封装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/02/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%81%E8%A3%85/" class="article-date">
  <time datetime="2022-12-02T03:09:24.000Z" itemprop="datePublished">2022-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/02/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%81%E8%A3%85/">线程同步机制的封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RALL"><a href="#RALL" class="headerlink" title="RALL"></a>RALL</h2><ul>
<li>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</li>
<li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定</li>
<li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子。</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待(P)和信号(V).假设有信号量SV，对其的P、V操作如下：</p>
<blockquote>
<ul>
<li>P，如果SV的值大于0，则将其减一；若SV的值为0，则挂起执行</li>
<li>V，如果有其他进行因为等待SV而挂起，则唤醒；若没有，则将SV值加一</li>
</ul>
</blockquote>
<p>信号量的取值可以是任何自然数，最常用的，最简单的信号量是二进制信号量，只有0和1两个值.</p>
<blockquote>
<ul>
<li>sem_init函数用于初始化一个未命名的信号量</li>
<li>sem_destory函数用于销毁信号量</li>
<li>sem_wait函数将以原子操作方式将信号量减一,信号量为0时,sem_wait阻塞</li>
<li>sem_post函数以原子操作方式将信号量加一,信号量大于0时,唤醒调用sem_post的线程</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno。</p>
<h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a><strong>互斥量</strong></h2><p>互斥锁,也成互斥量,可以保护关键代码段,以确保独占式访问.当进入关键代码段,获得互斥锁将其加锁;离开关键代码段,唤醒等待该互斥锁的线程.</p>
<blockquote>
<ul>
<li>pthread_mutex_init函数用于初始化互斥锁</li>
<li>pthread_mutex_destory函数用于销毁互斥锁</li>
<li>pthread_mutex_lock函数以原子操作方式给互斥锁加锁</li>
<li>pthread_mutex_unlock函数以原子操作方式给互斥锁解锁</li>
</ul>
</blockquote>
<p>以上，成功返回0，失败返回errno</p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a><strong>条件变量</strong></h2><p>条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.</p>
<blockquote>
<ul>
<li>pthread_cond_init函数用于初始化条件变量</li>
<li>pthread_cond_destory函数销毁条件变量</li>
<li>pthread_cond_broadcast函数以广播的方式唤醒<strong>所有</strong>等待目标条件变量的线程</li>
<li>pthread_cond_wait函数用于等待目标条件变量.该函数调用时需要传入 <strong>mutex参数(加锁的互斥锁)</strong> ,函数执行时,先把调用线程放入条件变量的请求队列,然后将互斥锁mutex解锁,当函数成功返回为0时,互斥锁会再次被锁上. <strong>也就是说函数内部会有一次解锁和加锁操作</strong>.</li>
</ul>
</blockquote>
<p>条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p>
<ul>
<li>一个线程因等待”条件变量的条件成立”而挂起；</li>
<li>另外一个线程使”条件成立”，给出信号，从而唤醒被等待的线程。</li>
</ul>
<p>多线程例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_id</span> <span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;<span class="comment">// 首先执行到这一句的第一个线程会lck.lock(), 其他线程则会卡在这一句；</span></span><br><span class="line">  cv.<span class="built_in">wait</span>(lck);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这个函数比较有意思，当执行到这一行的时候，他会lck.unlock(), 然后条件变量接替开始阻塞，这样第二个线程就会</span></span><br><span class="line"><span class="comment">  执行上一句lck初始化，然后所有线程都会走一遍lck.lock()-&gt;lck.unlock()-&gt;阻塞，然后所有线程都停留在这个位置，</span></span><br><span class="line"><span class="comment">  等待通知，最先得到通知的线程会调用lck.lock()(至于谁先得到通知线程去竞争了)，这样就保证下面这句命令操作的原子性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;<span class="comment">//类似于只能指针，lck自动unlock</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) threads[i] = std::<span class="built_in">thread</span>(print_id,i);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;10 threads ready to race...\n&quot;</span>;</span><br><span class="line">  <span class="built_in">go</span>()；<span class="comment">//主线程lck.lock()-&gt;通知所有wait-&gt;                      </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) &#123;</span><br><span class="line">     th.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁机制的功能"><a href="#锁机制的功能" class="headerlink" title="锁机制的功能"></a><strong>锁机制的功能</strong></h2><ul>
<li>实现多线程同步，通过锁机制，确保任一时刻只能有一个线程能进入关键代码段.</li>
</ul>
<h2 id="信号量的封装"><a href="#信号量的封装" class="headerlink" title="信号量的封装"></a>信号量的封装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 信号量 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem</span>(<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;m_sem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="互斥量的封装"><a href="#互斥量的封装" class="headerlink" title="互斥量的封装"></a>互斥量的封装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">locker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="条件变量的封装"><a href="#条件变量的封装" class="headerlink" title="条件变量的封装"></a>条件变量的封装</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//pthread_mutex_destroy(&amp;m_mutex);</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">timewait</span><span class="params">(<span class="type">pthread_mutex_t</span> *m_mutex, <span class="keyword">struct</span> timespec t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//pthread_mutex_lock(&amp;m_mutex);</span></span><br><span class="line">        ret = <span class="built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;m_mutex);</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">broadcast</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_broadcast</span>(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//static pthread_mutex_t m_mutex;</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/02/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%81%E8%A3%85/" data-id="clb62xv1h00002omj5ab5ees4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qemu相关配置参数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/28/qemu%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/" class="article-date">
  <time datetime="2022-11-28T02:52:57.000Z" itemprop="datePublished">2022-11-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/28/qemu%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/">qemu相关配置参数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-M</td>
<td>设备类型</td>
</tr>
<tr>
<td>-cpu</td>
<td>cpu类型</td>
</tr>
<tr>
<td>-m</td>
<td>内存大小</td>
</tr>
<tr>
<td>-smp</td>
<td>cpu核心数</td>
</tr>
<tr>
<td>-kernel</td>
<td>内核镜像</td>
</tr>
<tr>
<td>-nographic</td>
<td>使qemu成为简单的命令行应用程序</td>
</tr>
<tr>
<td>-serial stdio</td>
<td>host设备的标准输入输出</td>
</tr>
<tr>
<td>-S</td>
<td>启动qemu后不立即执行</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/28/qemu%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/" data-id="clb2z32q50000gomjbp2f8kyf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-epoll实现一个简易服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/24/epoll%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time datetime="2022-11-24T09:22:43.000Z" itemprop="datePublished">2022-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/24/epoll%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/">epoll实现一个简易服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="EPOLL三个主要接口："><a href="#EPOLL三个主要接口：" class="headerlink" title="EPOLL三个主要接口："></a>EPOLL三个主要接口：</h2><h3 id="int-epoll-create-int-size-创建一棵监听红黑树"><a href="#int-epoll-create-int-size-创建一棵监听红黑树" class="headerlink" title="int epoll_create(int size);        创建一棵监听红黑树"></a>int epoll_create(int size);        创建一棵监听红黑树</h3><p>size：创建的红黑树的监听节点数量。（仅供内核参考。）</p>
<p>返回值：指向新创建的红黑树的根节点的 fd。 </p>
<p>失败： -1 errno</p>
<h3 id="int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-操作监听红黑树"><a href="#int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event-操作监听红黑树" class="headerlink" title="int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);    操作监听红黑树"></a>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);    操作监听红黑树</h3><p>epfd：epoll_create 函数的返回值。 epfd</p>
<p>op：对该监听红黑数所做的操作。</p>
<p>​        EPOLL_CTL_ADD 添加fd到 监听红黑树</p>
<p>​        EPOLL_CTL_MOD 修改fd在 监听红黑树上的监听事件。</p>
<p>​        EPOLL_CTL_DEL 将一个fd 从监听红黑树上摘下（取消监听）</p>
<p>fd：<br>        待监听的fd</p>
<p>event：    本质 struct epoll_event 结构体 地址</p>
<p>​    成员 events：</p>
<p>​            EPOLLIN / EPOLLOUT / EPOLLERR</p>
<p>​    成员 data： 联合体（共用体）：</p>
<p>​            int fd;      对应监听事件的 fd</p>
<p>​            void *ptr； </p>
<p>​            uint32_t u32;</p>
<p>​            uint64_t u64;        </p>
<p>​    返回值：成功 0； 失败： -1 errno</p>
<h2 id="int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout-阻塞监听。"><a href="#int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout-阻塞监听。" class="headerlink" title="int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);      阻塞监听。"></a>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);      阻塞监听。</h2><p>epfd：epoll_create 函数的返回值。 epfd</p>
<p>events：传出参数，【数组】， 满足监听条件的 哪些 fd 结构体。</p>
<p>maxevents：数组 元素的总个数。 1024</p>
<pre><code>    struct epoll_event evnets[1024]
</code></pre>
<p>timeout：</p>
<p>​        -1: 阻塞</p>
<p>​        0： 不阻塞</p>
<p>​        &gt;0: 超时时间 （毫秒）</p>
<p>返回值：</p>
<p>​        &gt; 0: 满足监听的 总个数。 可以用作循环上限。</p>
<p>​        0： 没有fd满足监听事件</p>
<p>​        -1：失败。 errno</p>
<h2 id="epoll实现多路IO转接思路："><a href="#epoll实现多路IO转接思路：" class="headerlink" title="epoll实现多路IO转接思路："></a>epoll实现多路IO转接思路：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">lfd = socket（）;			监听连接事件lfd</span><br><span class="line"><span class="title function_">bind</span><span class="params">()</span>;</span><br><span class="line">listen();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epfd = epoll_create(<span class="number">1024</span>);				epfd, 监听红黑树的树根。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[1024];</span>			tep, 用来设置单个fd属性， ep 是 epoll_wait() 传出的满足监听事件的数组。</span><br><span class="line"></span><br><span class="line">tep.events = EPOLLIN;					初始化  lfd的监听属性。</span><br><span class="line">tep.data.fd = lfd</span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd， EPOLL_CTL_ADD, lfd, &amp;tep);		将 lfd 添加到监听红黑树上。</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">ret = epoll_wait(epfd， ep，<span class="number">1024</span>， <span class="number">-1</span>);			实施监听</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (ep[i].data.fd == lfd) &#123;				<span class="comment">// lfd 满足读事件，有新的客户端发起连接请求</span></span><br><span class="line"></span><br><span class="line">​		cfd = Accept();</span><br><span class="line"></span><br><span class="line">​		tep.events = EPOLLIN;				初始化  cfd的监听属性。</span><br><span class="line">​		tep.data.fd = cfd;</span><br><span class="line"></span><br><span class="line">​		epoll_ctl(epfd， EPOLL_CTL_ADD, cfd, &amp;tep);</span><br><span class="line"></span><br><span class="line">​	&#125; <span class="keyword">else</span> &#123;						cfd 们 满足读事件， 有客户端写数据来。</span><br><span class="line"></span><br><span class="line">​		n = read(ep[i].data.fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">​		<span class="keyword">if</span> ( n == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">​			close(ep[i].data.fd);</span><br><span class="line"></span><br><span class="line">​			epoll_ctl(epfd， EPOLL_CTL_DEL, ep[i].data.fd , <span class="literal">NULL</span>);	<span class="comment">// 将关闭的cfd，从监听树上摘下。</span></span><br><span class="line"></span><br><span class="line">​		&#125; <span class="keyword">else</span> <span class="keyword">if</span> （n &gt; <span class="number">0</span>） &#123;</span><br><span class="line"></span><br><span class="line">​			小--大</span><br><span class="line">​			write(ep[i].data.fd, buf, n);</span><br><span class="line">​		&#125;</span><br><span class="line">​	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务器具体实现"><a href="#服务器具体实现" class="headerlink" title="服务器具体实现"></a>服务器具体实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;wrap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 8192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN_MAX 5000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, listenfd, connfd, sockfd;</span><br><span class="line">    <span class="type">int</span>  n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">ssize_t</span> nready, efd, res;</span><br><span class="line">    <span class="type">char</span> buf[MAXLINE], str[INET_ADDRSTRLEN];</span><br><span class="line">    <span class="type">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>, <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt));      <span class="comment">//端口复用</span></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(SERV_PORT);</span><br><span class="line">    Bind(listenfd, (<span class="keyword">struct</span> sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    Listen(listenfd, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    efd = epoll_create(OPEN_MAX);               <span class="comment">//创建epoll模型, efd指向红黑树根节点</span></span><br><span class="line">    <span class="keyword">if</span> (efd == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">&quot;epoll_create error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">tep</span>, <span class="title">ep</span>[<span class="title">OPEN_MAX</span>];</span>       <span class="comment">//tep: epoll_ctl参数  ep[] : epoll_wait参数</span></span><br><span class="line"></span><br><span class="line">    tep.events = EPOLLIN; </span><br><span class="line">    tep.data.fd = listenfd;           <span class="comment">//指定lfd的监听时间为&quot;读&quot;</span></span><br><span class="line"></span><br><span class="line">    res = epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &amp;tep);    <span class="comment">//将lfd及对应的结构体设置到树上,efd可找到该树</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        perr_exit(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">/*epoll为server阻塞监听事件, ep为struct epoll_event类型数组, OPEN_MAX为数组容量, -1表永久阻塞*/</span></span><br><span class="line">        nready = epoll_wait(efd, ep, OPEN_MAX, <span class="number">-1</span>); </span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            perr_exit(<span class="string">&quot;epoll_wait error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nready; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(ep[i].events &amp; EPOLLIN))      <span class="comment">//如果不是&quot;读&quot;事件, 继续循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ep[i].data.fd == listenfd) &#123;    <span class="comment">//判断满足事件的fd是不是lfd            </span></span><br><span class="line">                clilen = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                connfd = Accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;clilen);    <span class="comment">//接受链接</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;received from %s at PORT %d\n&quot;</span>, </span><br><span class="line">                        inet_ntop(AF_INET, &amp;cliaddr.sin_addr, str, <span class="keyword">sizeof</span>(str)), </span><br><span class="line">                        ntohs(cliaddr.sin_port));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;cfd %d---client %d\n&quot;</span>, connfd, ++num);</span><br><span class="line"></span><br><span class="line">                tep.events = EPOLLIN; tep.data.fd = connfd;</span><br><span class="line">                res = epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &amp;tep);      <span class="comment">//加入红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                    perr_exit(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                                    <span class="comment">//不是lfd, </span></span><br><span class="line">                sockfd = ep[i].data.fd;</span><br><span class="line">                n = Read(sockfd, buf, MAXLINE);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;                                           <span class="comment">//读到0,说明客户端关闭链接</span></span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);  <span class="comment">//将该文件描述符从红黑树摘除</span></span><br><span class="line">                    <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">                        perr_exit(<span class="string">&quot;epoll_ctl error&quot;</span>);</span><br><span class="line">                    Close(sockfd);                                      <span class="comment">//关闭与该客户端的链接</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client[%d] closed connection\n&quot;</span>, sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;                                     <span class="comment">//出错</span></span><br><span class="line">                    perror(<span class="string">&quot;read n &lt; 0 error: &quot;</span>);</span><br><span class="line">                    res = epoll_ctl(efd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);  <span class="comment">//摘除节点</span></span><br><span class="line">                    Close(sockfd);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                                <span class="comment">//实际读到了字节数</span></span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                        buf[i] = <span class="built_in">toupper</span>(buf[i]);                       <span class="comment">//转大写,写回给客户端</span></span><br><span class="line"></span><br><span class="line">                    Write(STDOUT_FILENO, buf, n);</span><br><span class="line">                    Writen(sockfd, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Close(listenfd);</span><br><span class="line">    Close(efd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wrap.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">	perror(s);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ((n = accept(fd, sa, salenptr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			perr_exit(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = bind(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = connect(fd, sa, salen)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = listen(fd, backlog)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((n = socket(family, type, protocol)) &lt; <span class="number">0</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = read(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">	<span class="keyword">if</span> ( (n = write(fd, ptr, nbytes)) == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">			<span class="keyword">goto</span> again;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">	<span class="keyword">if</span> ((n = close(fd)) == <span class="number">-1</span>)</span><br><span class="line">		perr_exit(<span class="string">&quot;close error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*参三: 应该读取的字节数*/</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span>  nleft;              <span class="comment">//usigned int 剩余未读取的字节数</span></span><br><span class="line">	<span class="type">ssize_t</span> nread;              <span class="comment">//int 实际读到的字节数</span></span><br><span class="line">	<span class="type">char</span>   *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((nread = read(fd, ptr, nleft)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				nread = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		nleft -= nread;</span><br><span class="line">		ptr += nread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n - nleft;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> nleft;</span><br><span class="line">	<span class="type">ssize_t</span> nwritten;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	nleft = n;</span><br><span class="line">	<span class="keyword">while</span> (nleft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (nwritten = write(fd, ptr, nleft)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nwritten &lt; <span class="number">0</span> &amp;&amp; errno == EINTR)</span><br><span class="line">				nwritten = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		nleft -= nwritten;</span><br><span class="line">		ptr += nwritten;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> read_cnt;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *read_ptr;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> read_buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (read_cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">again:</span><br><span class="line">		<span class="keyword">if</span> ( (read_cnt = read(fd, read_buf, <span class="keyword">sizeof</span>(read_buf))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">				<span class="keyword">goto</span> again;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (read_cnt == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		read_ptr = read_buf;</span><br><span class="line">	&#125;</span><br><span class="line">	read_cnt--;</span><br><span class="line">	*ptr = *read_ptr++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ssize_t</span> n, rc;</span><br><span class="line">	<span class="type">char</span>    c, *ptr;</span><br><span class="line"></span><br><span class="line">	ptr = vptr;</span><br><span class="line">	<span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; maxlen; n++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( (rc = my_read(fd, &amp;c)) == <span class="number">1</span>) &#123;</span><br><span class="line">			*ptr++ = c;</span><br><span class="line">			<span class="keyword">if</span> (c  == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">			*ptr = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>wrap.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __WRAP_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __WRAP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">perr_exit</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Accept</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> *salenptr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Bind</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Connect</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa, <span class="type">socklen_t</span> salen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Listen</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Socket</span><span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readn</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Writen</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *vptr, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">my_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *ptr)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">Readline</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *vptr, <span class="type">size_t</span> maxlen)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/24/epoll%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="clauvzswd0000momj3n617mzr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编译nuclei-qemu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/" class="article-date">
  <time datetime="2022-11-15T05:26:16.000Z" itemprop="datePublished">2022-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/">编译nuclei-qemu</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Windows-上编译qemu"><a href="#Windows-上编译qemu" class="headerlink" title="Windows 上编译qemu"></a>Windows 上编译qemu</h2><h3 id="1、安装msys2"><a href="#1、安装msys2" class="headerlink" title="1、安装msys2"></a>1、安装msys2</h3><p>msys2官网网址<a target="_blank" rel="noopener" href="http://www.msys2.org/">http://www.msys2.org/</a></p>
<h3 id="2、运行msys2-exe"><a href="#2、运行msys2-exe" class="headerlink" title="2、运行msys2.exe"></a>2、运行msys2.exe</h3><p>a.) 执行pacman -Syu更新系统到最新，更新完后系统会要求重启，关掉msys2 shell.</p>
<p>b.)重新启动msys2.exe<br>   执行pacman -Su，看是否还有更新，如果有则更新。</p>
<h3 id="3、替换软件源"><a href="#3、替换软件源" class="headerlink" title="3、替换软件源"></a>3、替换软件源</h3><p>配置一下pacman使用清华大学的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=%5Bhttps://mirror.tuna.tsinghua.edu.cn/help/msys2/%5D(https://mirror.tuna.tsinghua.edu.cn/help/msys2/)">镜像</a>（PS：其实安装包也可以从清华大学镜像站中下载）。修改方法如下：</p>
<p>编辑 <code>/etc/pacman.d/mirrorlist.mingw32</code> ，在文件开头添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686</span></span><br></pre></td></tr></table></figure>

<p>编辑 <code>/etc/pacman.d/mirrorlist.mingw64</code> ，在文件开头添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</span></span><br></pre></td></tr></table></figure>

<p>编辑 <code>/etc/pacman.d/mirrorlist.msys</code> ，在文件开头添加：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = <span class="symbol">https:</span>/<span class="regexp">/mirrors.tuna.tsinghua.edu.cn/msys</span>2/msys/$arch</span><br></pre></td></tr></table></figure>

<p>然后执行<code>pacman -Syu</code>刷新软件包并且更新mysys2系统组件即可，然后重启shell。</p>
<p>上面的/etc/是指mysys的安装目录下的etc目录。</p>
<p><strong>安装ninja</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ninja-build/ninja.git</span><br><span class="line">./configure.py --bootstrap   #在ninja目录中执行</span><br><span class="line">cp ./ninja  /usr/bin  #在ninja目录中执行，这样即可任意位置使用ninja</span><br><span class="line">ninja --version</span><br></pre></td></tr></table></figure>

<h3 id="4、快速安装所有mingw"><a href="#4、快速安装所有mingw" class="headerlink" title="4、快速安装所有mingw"></a>4、快速安装所有mingw</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S  mingw-w64-i686-toolchain</span><br><span class="line">pacman -S  mingw-w64-x86_64-toolchain</span><br></pre></td></tr></table></figure>

<h3 id="5、msys2启动入口"><a href="#5、msys2启动入口" class="headerlink" title="5、msys2启动入口"></a>5、msys2启动入口</h3><p>安装Msys2后，或解压Msys2后，第一次运行下msys2_shell.cmd，提示第一次设置初始化完毕后，就可以运行Msys2.exe、mingw64.exe或mingw32.exe，主要区别：</p>
<ul>
<li>mingw32 优先使用 msys64/mingw32 下的工具;</li>
<li>mingw64 优先使用 msys64/mingw64 下的工具;</li>
<li>msys2 两个都不使用，只用自身 msys 的工具;82</li>
</ul>
<h3 id="6、其它常用软件或库"><a href="#6、其它常用软件或库" class="headerlink" title="6、其它常用软件或库"></a>6、其它常用软件或库</h3><p><code>pacman -S base-devel git wget p7zip perl ruby python2</code> ，不过有些上面安装过程中已经安装了。</p>
<h3 id="7、拉取nuclei-qemu源代码"><a href="#7、拉取nuclei-qemu源代码" class="headerlink" title="7、拉取nuclei-qemu源代码"></a>7、拉取nuclei-qemu源代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone -b plct-nuclei-rebase https://github.com/plctlab/plct-qemu.git</span><br><span class="line">cd plct-nuclei</span><br><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update --remote --recursive</span><br></pre></td></tr></table></figure>

<p>只编译riscv32位的qemu，在configure中指定target-list=riscv32-softmmu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">../configure --target-list=riscv32-softmmu --disable-werror</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<h3 id="8、验证qemu编译是否成功"><a href="#8、验证qemu编译是否成功" class="headerlink" title="8、验证qemu编译是否成功"></a>8、验证qemu编译是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-riscv32.exe --version</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QEMU emulator version 5.2.90 (v5.0.0-rc2-9705-geaabfc7ea0)</span><br><span class="line">Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<p>说明编译成功，但是此时的qemu在用图形化界面时，会发生错误，因为它依赖于mingw64的环境，缺少了一些dll库，将msys2根目录下的mingw64的bin目录下的文件全部复制到qemu-system-riscv32的同级目录下，即可运行。</p>
<p><img src="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/image-20221115135341921.png" alt="image-20221115135341921"></p>
<h3 id="9、使用nuclei-qemu运行helloworld例程"><a href="#9、使用nuclei-qemu运行helloworld例程" class="headerlink" title="9、使用nuclei-qemu运行helloworld例程"></a>9、使用nuclei-qemu运行helloworld例程</h3><p>例程是nuclei studio上的helloworld程序，可以通过nuclei ide的qemu上运行的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M ?</span><br><span class="line">Supported machines are:</span><br><span class="line">gd32vf103_eval       RISC-V Nuclei GD32VF103 Eval Board</span><br><span class="line">gd32vf103_rvstar     RISC-V Nuclei GD32VF103 Rvstar Board</span><br><span class="line">hbird_fpga           Nuclei HummingBird Evaluation Kit</span><br><span class="line">none                 empty machine</span><br><span class="line">opentitan            RISC-V Board compatible with OpenTitan</span><br><span class="line">sifive_e             RISC-V Board compatible with SiFive E SDK</span><br><span class="line">sifive_u             RISC-V Board compatible with SiFive U SDK</span><br><span class="line">spike                RISC-V Spike board (default)</span><br><span class="line">virt                 RISC-V VirtIO board</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M gd32vf103_eval -nographic -kernel 5_helloworld.elf</span><br><span class="line">Nuclei SDK Build Time: Nov 15 2022, 10:26:49</span><br><span class="line">Download Mode: FLASHXIP</span><br><span class="line">CPU Frequency 269500000 Hz</span><br><span class="line">Hart 0, MISA: 0x40101105</span><br><span class="line">MISA: RV32IMACU</span><br><span class="line">0: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">1: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">2: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">3: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">4: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">5: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">6: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">7: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">8: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">9: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">10: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">11: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">12: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">13: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">14: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">15: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">16: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">17: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">18: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">19: Hello World From Nuclei RISC-V Processor!</span><br></pre></td></tr></table></figure>

<p>在ide中其实就是给qemu发送了命令，实现的<strong>运行仿真</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M gd32vf103_eval -nographic -kernel 5_helloworld.elf</span><br></pre></td></tr></table></figure>

<p>  -M：指定模拟哪个目标板，这个一定得是qemu支持的，否则会提示错误。从上面我们可以知道，RT-Thread的生态里qemu是支持了这个stm32f407-atk-explorer板子的了</p>
<p>-nographic：告诉qemu无界面启动（因为默认有一个类似VMware那样的界面），这个非常重要，这样程序中串口打印信息（printf）才能输出到控制台来，否则不会有任何输出。（qemu help的解释：-nographic      disable graphical output and redirect serial I/Os to console），所以我们别去调用什么-serial stdio啥的命令，否则也不会输出。</p>
<p>-kernel：指定程序镜像文件，这个可以是bin文件，elf文件（含有调试信息）都可以<br>如果是<strong>调试仿真</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M gd32vf103_eval -nographic -S -s -kernel 5_helloworld.elf</span><br></pre></td></tr></table></figure>

<p>-S：代表不自动运行模拟（需要gdb连接之后进行操作）</p>
<p>-s：代表开放tcp1234作为远程调试端口</p>
<p>nuclei-studio中有关qemu的配置</p>
<p><img src="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/image-20221115140543751.png" alt="image-20221115140543751"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/" data-id="clahtazjr00008kmjfoowgfhv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spike相关理解1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/" class="article-date">
  <time datetime="2022-11-03T08:36:54.000Z" itemprop="datePublished">2022-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/">spike相关理解1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="spike整体结构"><a href="#spike整体结构" class="headerlink" title="spike整体结构"></a>spike整体结构</h2><ul>
<li><strong>fdt</strong>：为模拟器生成device tree，包括cpu数量，内存的大小等</li>
<li><strong>fesvr</strong>：提供了target与主机host交互的接口（借助proxy kernel实现，pk处理application代码中的系统调用，但是实际上要导到host os中进行处理，他们之间就是通过fesvr来进行通信的）</li>
<li><strong>softfloat库提供了浮点数的支持</strong></li>
<li><strong>riscv实现了risc-v机器码的翻译和执行</strong></li>
<li>spike_main: 程序的entry_point和interface</li>
</ul>
<h2 id="spike模拟器执行binary的流程"><a href="#spike模拟器执行binary的流程" class="headerlink" title="spike模拟器执行binary的流程"></a>spike模拟器执行binary的流程</h2><ul>
<li>解码，将机器码要翻译成指令</li>
<li>memory load and store  维护内存</li>
<li>maintain register 维护寄存器</li>
<li>debug mode — like a tiny gdb 提供一个接口类似于gdb</li>
<li>执行指令</li>
</ul>
<h2 id="Spike-CPU的指令执⾏过程"><a href="#Spike-CPU的指令执⾏过程" class="headerlink" title="Spike CPU的指令执⾏过程"></a><strong>Spike CPU</strong>的指令执⾏过程</h2><ul>
<li><p> Spike执⾏代码时，执⾏的实际上是C++ Function</p>
</li>
<li><p> CPU从pc指针处读取指令，通过译码来确定接下来要执⾏的功能 </p>
</li>
<li><p> 指令的⾏为定义在riscv/insns下的 指令名称.h⽂件中</p>
</li>
<li><p>指令的编码定义在riscv/encoding.h中</p>
<p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103165247326.png" alt="image-20221103165247326"></p>
</li>
<li><p> 定义⼀条指令需要定义如下内容：</p>
</li>
<li><p> #defifine MATCH_[instruction name] 0x12341234  // 指令的操作码</p>
</li>
<li><p> #defifine MASK_[instruction name] 0xabcdabcd  //指令的掩码，把不需要的不是参数的位置为一可以起到屏蔽作用</p>
</li>
<li><p> DECLARE_INSN(XXX, MATCH_XXX, MASK_XXX) // 将指令函数，指令操作码，指令掩码联系在一起</p>
</li>
<li><p> alternative：通过riscv-opcodes⽣成encoding.h</p>
</li>
</ul>
<p> 例：riscv/insns/lw.h</p>
<p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103170520594.png" alt="image-20221103170520594"></p>
<p>实际上模拟指令的⾏为相当于写对应的c++ function</p>
<p> riscv/decode.h中定义了⼀系列操作存储器和寄存器的宏定义，以便于在指令中操作它们</p>
<h2 id="fesvr-模块简介"><a href="#fesvr-模块简介" class="headerlink" title="fesvr 模块简介"></a><strong>fesvr</strong> <strong>模块简介</strong></h2><ul>
<li> <strong>fesvr， 全称是 risc-v front-end server</strong></li>
<li>主要用来实现simulation target 与host 主机的交互</li>
</ul>
<p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103171413134.png" alt="image-20221103171413134"></p>
<p>spike并没有模拟外部设备，所以需要I/O会产生中断，用host os处理。 htif 全称 host target interface。</p>
<h2 id="Spike-启动simulation的过程"><a href="#Spike-启动simulation的过程" class="headerlink" title="Spike 启动simulation的过程"></a><strong>Spike</strong> <strong>启动simulation</strong>的过程</h2><p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103171954856.png" alt="image-20221103171954856"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/" data-id="cla0we55t00009cmj5sj4ecku" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qemu新增Soc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/" class="article-date">
  <time datetime="2022-11-02T05:25:32.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/">qemu新增Soc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RISC-V模拟器分类"><a href="#RISC-V模拟器分类" class="headerlink" title="RISC-V模拟器分类"></a>RISC-V模拟器分类</h2><p>• Functional(QEMU)：采⽤⼆进制翻译，实际执⾏的是翻译之后的机器码，执⾏效率⾼</p>
<p>• Trace-accurate(Spike) :模拟实际代码执⾏过程中的软硬件⾏为，提供指令级别的仿真</p>
<p>• Cycle-accurate：提供硬件级别的仿真，可以针对特定的实现作周期级别的模拟</p>
<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102144255567.png" alt="image-20221102144255567"></p>
<h2 id="qemu基本结构"><a href="#qemu基本结构" class="headerlink" title="qemu基本结构"></a>qemu基本结构</h2><p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221103175755756.png" alt="image-20221103175755756"></p>
<h2 id="QEMU中Soc的添加"><a href="#QEMU中Soc的添加" class="headerlink" title="QEMU中Soc的添加"></a>QEMU中Soc的添加</h2><p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221107105900475.png" alt="image-20221107105900475"></p>
<h3 id="Cpu模拟"><a href="#Cpu模拟" class="headerlink" title="Cpu模拟"></a>Cpu模拟</h3><p>QOM模型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyDevice</span>&#123;</span></span><br><span class="line">	DeviceState parent;   <span class="comment">// 父设备</span></span><br><span class="line">	<span class="type">int</span> reg0,reg1;</span><br><span class="line">&#125;MyDevice</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyDeviceClass</span>&#123;</span></span><br><span class="line">    DeviceClass parent; </span><br><span class="line">    <span class="type">void</span> (*init)(MyDevice *obj);    </span><br><span class="line">&#125;MyDeviceClass;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_device_register_types</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    type_register_static(&amp;my_device_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(my_device_register_types);</span><br></pre></td></tr></table></figure>

<p>Risc-V cpu：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RISCVCPU</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    CPUState parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    CPUNegativeOffsetState neg; </span><br><span class="line">    CPURISCVState env;  <span class="comment">//存储riscv cpu相关的寄存器和上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configuration Settings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> ext_i;</span><br><span class="line">        <span class="type">bool</span> ext_e;</span><br><span class="line">        <span class="type">bool</span> ext_g;</span><br><span class="line">        <span class="type">bool</span> ext_m;</span><br><span class="line">        <span class="type">bool</span> ext_a;</span><br><span class="line">        <span class="type">bool</span> ext_f;</span><br><span class="line">        <span class="type">bool</span> ext_d;</span><br><span class="line">        <span class="type">bool</span> ext_c;</span><br><span class="line">        <span class="type">bool</span> ext_s;</span><br><span class="line">        <span class="type">bool</span> ext_u;</span><br><span class="line">        <span class="type">bool</span> ext_h;</span><br><span class="line">        <span class="type">bool</span> ext_counters;</span><br><span class="line">        <span class="type">bool</span> ext_ifencei;</span><br><span class="line">        <span class="type">bool</span> ext_icsr;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *priv_spec;</span><br><span class="line">        <span class="type">char</span> *user_spec;</span><br><span class="line">        <span class="type">bool</span> mmu;</span><br><span class="line">        <span class="type">bool</span> pmp;</span><br><span class="line">    &#125; cfg;</span><br><span class="line">&#125; RISCVCPU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RISCVCPUClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    CPUClass parent_class;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    DeviceRealize parent_realize;</span><br><span class="line">    DeviceReset parent_reset;</span><br><span class="line">&#125; RISCVCPUClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*相关寄存器的一些操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_priv_version</span><span class="params">(CPURISCVState *env, <span class="type">int</span> priv_ver)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;priv_ver = priv_ver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_feature</span><span class="params">(CPURISCVState *env, <span class="type">int</span> feature)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;features |= (<span class="number">1ULL</span> &lt;&lt; feature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_resetvec</span><span class="params">(CPURISCVState *env, <span class="type">int</span> resetvec)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_USER_ONLY</span></span><br><span class="line">    env-&gt;resetvec = resetvec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">riscv_any_cpu_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPURISCVState *env = &amp;RISCV_CPU(obj)-&gt;env;</span><br><span class="line">    set_misa(env, RVXLEN | RVI | RVM | RVA | RVF | RVD | RVC | RVU);</span><br><span class="line">    set_priv_version(env, PRIV_VERSION_1_11_0);</span><br><span class="line">    set_resetvec(env, DEFAULT_RSTVEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*cpu 注册*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo riscv_cpu_type_infos[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = TYPE_RISCV_CPU,</span><br><span class="line">        .parent = TYPE_CPU,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(RISCVCPU),</span><br><span class="line">        .instance_init = riscv_cpu_init,</span><br><span class="line">        .abstract = <span class="literal">true</span>,</span><br><span class="line">        .class_size = <span class="keyword">sizeof</span>(RISCVCPUClass),</span><br><span class="line">        .class_init = riscv_cpu_class_init,</span><br><span class="line">    &#125;,</span><br><span class="line">    DEFINE_CPU(TYPE_RISCV_CPU_ANY,              riscv_any_cpu_init),</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(TARGET_RISCV32)</span></span><br><span class="line">   	。。。。。。。。。</span><br><span class="line">    DEFINE_CPU(TYPE_RISCV_CPU_NUCLEI_N307,    rv32imafcu_nuclei_cpu_init),</span><br><span class="line">    。。。。。。。。。</span><br><span class="line">    <span class="comment">/* Depreacted */</span></span><br><span class="line">   	。。。。。。。。。</span><br><span class="line">    DEFINE_CPU(TYPE_RISCV_CPU_RV64GCSU_V1_10_0, rv64gcsu_priv1_10_0_cpu_init)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DEFINE_TYPES(riscv_cpu_type_infos)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RISCV-CPU-指令扩展"><a href="#RISCV-CPU-指令扩展" class="headerlink" title="RISCV  CPU 指令扩展"></a>RISCV  CPU 指令扩展</h3><h3 id="RISCV-SOC-CSR扩展"><a href="#RISCV-SOC-CSR扩展" class="headerlink" title="RISCV SOC CSR扩展"></a>RISCV SOC CSR扩展</h3><p>qemu已经支持了csrrw，csrrs等相关的指令了，只需要调用相关的trans_csrrw等函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrw</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrs</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrc</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrwi</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br></pre></td></tr></table></figure>

<p>target/riscv/cpu_bits.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCH        0x340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MEPC            0x341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCAUSE          0x342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVAL           0x343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIP             0x344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MNXTI             0x345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MINTSTATUS        0x346</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCHCSW        0x348</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCHCSWL        0x349</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>target/riscv/csr.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_mmisc_ctl</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *val = env-&gt;mmisc_ctl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_mmisc_ctl</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong val)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;mmisc_ctl = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_msavestatus</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *val = env-&gt;msavestatus;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_msavestatus</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong val)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;msavestatus = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemmapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base;</span><br><span class="line">    hwaddr size;</span><br><span class="line">&#125; nuclei_memmap[] = &#123;</span><br><span class="line">    [GD32VF103_EXMC_SWREG] = &#123; <span class="number">0xA0000000</span>,     <span class="number">0x1000</span> &#125;,</span><br><span class="line">    [GD32VF103_EXMC_SWREG] = &#123; <span class="number">0x60000000</span>,     <span class="number">0x10000000</span> &#125;,</span><br><span class="line">    [GD32VF103_USBFS]      = &#123; <span class="number">0x50000000</span>,     <span class="number">0x100000</span> &#125;,</span><br><span class="line">    [GD32VF103_CRC]        = &#123; <span class="number">0x40023000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_FMC]        = &#123; <span class="number">0x40022000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_RCU]        = &#123; <span class="number">0x40021000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_DMA1]       = &#123; <span class="number">0x40020400</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_DMA0]       = &#123; <span class="number">0x40020000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_UART4]     = &#123; <span class="number">0x40005000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_USART0]     = &#123; <span class="number">0x40013800</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_SRAM]       = &#123; <span class="number">0x20000000</span>,     <span class="number">0x18000</span> &#125;,</span><br><span class="line">    [GD32VF103_OB]         = &#123; <span class="number">0x1FFFF800</span>,     <span class="number">0x10</span> &#125;,</span><br><span class="line">    [GD32VF103_BL]         = &#123; <span class="number">0x1FFFB000</span>,     <span class="number">0x800</span> &#125;,</span><br><span class="line">    [GD32VF103_MAINFLASH]  = &#123; <span class="number">0x8000000</span>,     <span class="number">0x20000</span> &#125;,</span><br><span class="line">    [GD32VF103_MFOL]       = &#123;        <span class="number">0x0</span>,     <span class="number">0x20000</span> &#125;,</span><br><span class="line">    [GD32VF103_ECLIC]      = &#123; <span class="number">0xD2000000</span>,     <span class="number">0x10000</span> &#125;,</span><br><span class="line">    [GD32VF103_TIMER0]      = &#123; <span class="number">0x40012C00</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_SYSTIMER]      = &#123; <span class="number">0xD1000000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_AFIO]      = &#123; <span class="number">0x40010000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOA]      = &#123; <span class="number">0x40010800</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOB]      = &#123; <span class="number">0x40010C00</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOC]      = &#123; <span class="number">0x40011000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOD]      = &#123; <span class="number">0x40011400</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOE]      = &#123; <span class="number">0x40011800</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102160816431.png" alt="image-20221102160816431"></p>
<p>ILM 和DLM示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize SOC */</span></span><br><span class="line">  object_initialize_child(OBJECT(machine), <span class="string">&quot;soc&quot;</span>, &amp;s-&gt;soc, <span class="keyword">sizeof</span>(s-&gt;soc),</span><br><span class="line">                          TYPE_NUCLEI_SOC, &amp;error_abort, <span class="literal">NULL</span>);</span><br><span class="line">  object_property_set_bool(OBJECT(&amp;s-&gt;soc), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>,</span><br><span class="line">                          &amp;error_abort);</span><br><span class="line"></span><br><span class="line">  memory_region_init_ram(&amp;s-&gt;soc.ilm, <span class="literal">NULL</span>, <span class="string">&quot;riscv.nuclei.ram.ilm&quot;</span>,</span><br><span class="line">                         memmap[NUCLEI_ILM].size, &amp;error_fatal);</span><br><span class="line">  memory_region_add_subregion(system_memory, </span><br><span class="line">  memmap[NUCLEI_ILM].base, &amp;s-&gt;soc.ilm);</span><br><span class="line"></span><br><span class="line">  memory_region_init_ram(&amp;s-&gt;soc.dlm, <span class="literal">NULL</span>, <span class="string">&quot;riscv.nuclei.ram.dlm&quot;</span>,</span><br><span class="line">                         memmap[NUCLEI_DLM].size, &amp;error_fatal);</span><br></pre></td></tr></table></figure>

<p>hw/gpio/nrf51_gpio</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nrf51_gpio_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    NRF51GPIOState *s = NRF51_GPIO(obj);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, obj, &amp;gpio_ops, s,</span><br><span class="line">            TYPE_NRF51_GPIO, NRF51_GPIO_SIZE);</span><br><span class="line">    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &amp;s-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    qdev_init_gpio_in(DEVICE(s), nrf51_gpio_set, NRF51_GPIO_PINS);</span><br><span class="line">    qdev_init_gpio_out(DEVICE(s), s-&gt;output, NRF51_GPIO_PINS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hw/riscv/nuclei_gd32vf103.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object_property_set_bool(OBJECT(&amp;s-&gt;gpioc), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br><span class="line"> object_property_set_bool(OBJECT(&amp;s-&gt;gpiod), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br><span class="line"> sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;gpioa), <span class="number">0</span>, memmap[GD32VF103_GPIOA].base);</span><br><span class="line"> sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;gpiob), <span class="number">0</span>, memmap[GD32VF103_GPIOB].base);</span><br></pre></td></tr></table></figure>

<h2 id="中断虚拟化"><a href="#中断虚拟化" class="headerlink" title="中断虚拟化"></a>中断虚拟化</h2><p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102161819367.png" alt="image-20221102161819367"></p>
<h2 id="外设虚拟化"><a href="#外设虚拟化" class="headerlink" title="外设虚拟化"></a>外设虚拟化</h2><p>uart，gpio等等。</p>
<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102165005081.png" alt="image-20221102165005081"></p>
<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102165105726.png" alt="image-20221102165105726"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/" data-id="cl9zgyneg0000wgmj3r2h4vuk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rtos中断流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/" class="article-date">
  <time datetime="2022-10-28T01:43:49.000Z" itemprop="datePublished">2022-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/">rtos中断流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RISCV中断和异常处理"><a href="#RISCV中断和异常处理" class="headerlink" title="RISCV中断和异常处理"></a>RISCV中断和异常处理</h2><p>RISCV架构下有三种特权级别，分别是Machine、Supervisor和User，简称M模式、S模式和U模式。M模式权限最高，在这个级别下的程序可以访问一切硬件和执行所有特权指令；S模式一般用于运行操作系统，可以设置MMU使用虚拟地址；U模式一般是普通应用程序使用，权限最低。</p>
<p>M模式使用物理地址进行访问，不经过MMU，但是有类似arm下cortex-m中的MPU功能；S模式可以通过设置MMU来使用虚拟地址访问内存，所以像Linux这类操作系统都运行在S模式下。那么有人要问了，为啥RISCV架构特权模式设计成这样，直接把M模式和S模式合二为一不行吗？这个得从RISCV架构诞生背景来看了，RISCV架构诞生于2010年左右，这时不管是x86还是arm架构都发展得算是比较成熟了，所以RISCV架构设计时就定位了从微控制器到大型超级计算机都可以使用这个架构。在微控制器上使用的RISCV架构一般只有M模式，或者使用M和U两种模式，类似于cortex-m架构的定位；而在带MMU的芯片上，RISCV架构一般都使用M、S和U三种模式，这样通过“拼积木”的方式就可以让RISCV架构适用于各种场景了。</p>
<p><strong>在arm下的应用程序通过“swi”指令可以将处理器从低特权级别切换到高特权级别，</strong>一般像Linux下的系统调用都是通过这种方式来使用的。类似的，<strong>在RISCV中，通过“ecall”指令可以从低特权切换到高特权</strong>，在U模式下执行就切换到S模式，在S模式下调用就切换到M模式。另外在RISCV中，默认产生中断和异常时，处理器自动切换到M模式处理，可以通过中断托管设置将一些中断和异常直接交给S模式处理。RISCV的架构设计就决定了必须要有程序运行在M模式下，来为S模式提供一些基础的服务，**RISCV为此定义了SBI(Supervisor Binary Interface)**接口规范，让运行在S模式下的操作系统在不同的RISCV处理器上都可以使用标准的SBI接口来使用相应的功能，这个其实就有点类似于x86下的BIOS概念了，详细的RISCV下中断和异常处理以及SBI规范在后续章节会讲解，这里只需要知道就可以。</p>
<h2 id="中断和异常处理"><a href="#中断和异常处理" class="headerlink" title="中断和异常处理"></a>中断和异常处理</h2><p>在RISCV架构设计中，有一系列的控制和状态寄存器( Control and Status Registers）简称CSR，在三种特权级别下都有其对应的CSR，比如m模式下的命名都为mxxxx，s模式下的都为sxxxx等等。这些寄存器的作用类似于arm架构中的那些cp15寄存器，用于设置异常向量表、设置页表基址、获取异常信息等等。这些寄存器大多数都需要通过“csr”这类指令来进行访问，也有一部分寄存器是采用mmio映射的，可以使用普通访存指令访问，比如timer相关的寄存器（后面会讲）。</p>
<table>
<thead>
<tr>
<th>CSR名称</th>
<th>访问属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>mvendorid</td>
<td>只读</td>
<td>厂商ID</td>
</tr>
<tr>
<td>marchId</td>
<td>只读</td>
<td>体系结构id</td>
</tr>
<tr>
<td>mimpid</td>
<td>只读</td>
<td>特点实现id</td>
</tr>
<tr>
<td>mhartid</td>
<td>只读</td>
<td>hart(硬件线程) id</td>
</tr>
<tr>
<td>misa</td>
<td>只读</td>
<td>指令集架构信息</td>
</tr>
<tr>
<td>mcycle/mycycleh</td>
<td>只读</td>
<td>时钟周期计数器</td>
</tr>
<tr>
<td>cycle/ycycleh</td>
<td>只读</td>
<td>时钟周期计数器</td>
</tr>
<tr>
<td>minstret</td>
<td>只读</td>
<td>退休指令计数器</td>
</tr>
<tr>
<td>mstatus</td>
<td>可读可写</td>
<td>状态控制</td>
</tr>
<tr>
<td>mie</td>
<td>可读可写</td>
<td>中断使能</td>
</tr>
<tr>
<td>mip</td>
<td>只读</td>
<td>当前中断pengding位</td>
</tr>
<tr>
<td>mtvec</td>
<td>可读可写</td>
<td>中断/异常矢量</td>
</tr>
<tr>
<td>mtval</td>
<td>可读可写</td>
<td>异常和中断的补充信息（如异常指令，非法地址）</td>
</tr>
<tr>
<td>mscratch</td>
<td>可读可写</td>
<td>提供一个上下文保存寄存器</td>
</tr>
<tr>
<td>mepc</td>
<td>可读可写</td>
<td>异常程序指针</td>
</tr>
<tr>
<td>mcause</td>
<td>只读</td>
<td>异常/中断原因</td>
</tr>
</tbody></table>
<p>上图中的寄存器被分为四类，其中和Trap相关的寄存器比较重要，用于中断和异常处理：</p>
<ul>
<li>信息类：主要用于获取当前芯片id和cpu核id等信息。</li>
<li>Trap设置：用于设置中断和异常相关寄存器。</li>
<li>Trap处理：用于处理中断和异常相关寄存器。</li>
<li>内存保护：作用类似于conterx-m中的mpu功能。</li>
</ul>
<h4 id="Machine-Information-Registers"><a href="#Machine-Information-Registers" class="headerlink" title="Machine Information Registers"></a>Machine Information Registers</h4><p>mvendorid、 marchid 和 mimpid 可以获取芯片制造商、架构和实现相关信息，最重要的还是 mhartid 这个寄存器，RISCV中每个cpu核都被称为一个hart，通过mhartid可以获取当前cpu核的id号。</p>
<h4 id="Machine-Trap-Setup"><a href="#Machine-Trap-Setup" class="headerlink" title="Machine Trap Setup"></a>Machine Trap Setup</h4><p>在RISCV中，中断（interrupt）和异常（exception）被统称为trap。在arm中我们知道中断和异常是通过中断向量表中不同入口调用不同的处理函数处理的，但是在riscv中，所有中断和异常一般都是使用的同一个处理入口。在x86和arm下都存在中断向量表的概念，用于定义不同异常和中断的处理入口，但是在riscv下，一般是不存在中断向量表这个概念的，只存在trap处理入口这个概念。为了表述上的方便，后续的章节都将trap处理入口称为中断入口，但是要明白这个入口不仅仅是处理中断的，同时也是处理异常的入口。中断入口在m模式和s模式下都有专门的寄存器需要设置，在本小节我们只看m模式下的相关寄存器，在使用中断和异常处理之前需要进行一些设置，下面就来看看这些寄存器如何设置。</p>
<h4 id="mtvec"><a href="#mtvec" class="headerlink" title="mtvec"></a>mtvec</h4><p>riscv支持向量中断和非向量中断两种编程模型， 非向量中断，也就是中断发生后，所有的入口只有一个，不固定偏移。</p>
<p> mtvec寄存器全名为Machine Trap-Vector Base-Address Register，用于设置中断入口地址，其寄存器格式如下</p>
<h1 id><a href="#" class="headerlink" title></a><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214110818111-230653853.png" alt="img"></h1><p> 可以看出mtvec需要中断入口地址是4字节对齐的，因为最低两个bit是用于设置中断模式的，其模式定义如下：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214111053532-1352962926.png" alt="img"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214110833752-872983711.png" alt="img"></p>
<ul>
<li>Direct模式：所有的中断和异常使用同一个中断入口地址，一般都会设置为这种模式。</li>
<li>Vectored模式：所有异常使用同一个入口地址，但是不同的中断使用不同的入口地址。</li>
</ul>
<h4 id="mstatus"><a href="#mstatus" class="headerlink" title="mstatus"></a>mstatus</h4><p>这个寄存器顾名思义是用来控制cpu核当前的一些状态信息的，比如全局中断使能等，寄存器的格式如下：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214110954103-633405226.png" alt="img"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214111004056-324285028.png" alt="img"></p>
<ul>
<li><p>红框内的位域用来控制全局中断的使能，SIE控制S模式下全局中断，MIE控制M模式下全局中断。这个有点像arm里cpsr中的F位，只是在RISCV架构下还分为S模式和M模式来控制，像但是不完全像。</p>
</li>
<li><p>绿框里的位域用来记录发生中断之前MIE和SIE的值。SPIE记录的是SIE的值，MPIE记录的是MIE的值。</p>
</li>
<li><p>蓝色框内位域用来记录当特权级别由低到高发生变化时（比如执行ecall指令），之前的特权级别。当变化后的特权级别是S模式时，SPP表示变化之前的特权级别是S模式还是U模式，所以只需要1位就可以表示；当变化后的特权级别是M模式时，MPP表示变化之前是S模式还是U模式还是M模式，由于有三种情况，所以需要使用2位来表示。</p>
</li>
<li><p>注意：当发生中断时，SIE和MIE被硬件自动设置为0，用来屏蔽中断，这个行为和大部分架构都一样，同时MPIE和SPIE被硬件自动设置为MIE和SIE的值，如果特权级别还发生改变的话，之前的特权级别是记录在SPP或者MPP中的。当从中断中返回时，SIE和MIE被自动设置为MPIE和SPIE的值，同时MPIE和SPIE被自动设置为1，特权级别恢复为MPP或者SPP记录的级别，然后MPP或者SPP被设置为U模式。</p>
</li>
</ul>
<h4 id="mie"><a href="#mie" class="headerlink" title="mie"></a>mie</h4><p>在RISCV下，将中断（interrupt）又细分为三种类型：定时中断(timer)、核间中断(soft)、中断控制器中断(external)。定时中断可以用于产生系统的tick，核间中断用于不同cpu核之间通信，中断控制器则负责所有外设中断。这个设计和arm下有点不一样，在arm多核下，架构中的定时器中断、核间中断和外设中断都是统一由中断控制器管理的，而在RISCV中定时器和核间中断是分离出来的，这两个中断被称为CLINT（Core Local Interrupt），而管理其他外设中断的中断控制器则被称为PLIC（Platform-Level Interrupt Controller）。每个核都有自己的定时器和产生核间中断的寄存器可以设置，这些寄存器的访问不同于其他的控制状态寄存器，采用的是MMIO映射方式访问，比如下图所示为SIFIVE FU540的CLINT寄存器表：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214114537637-1524564992.png" alt="img"></p>
<p>图中的msip用于产生m模式下的核间中断，mtime可以读取出当前计数器的值，mtimecmp用于设置比较值，当mtime的值增加到mtimecmp的值时就可以产生中断。这些寄存器的具体用法在后续的裸机程序编写章节会讲解，这里只需要简单了解即可。</p>
<p>上述讲解的三种中断类型在m模式和s模式下都有相应的中断使能位设置，这是通过mie寄存器实现的<strong>，mie寄存器的格式如下：</strong></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214114633507-942051388.png" alt="img"></p>
<ul>
<li>MSIE、MTIE、MEIE这三个位域分别控制m模式下核间中断、定时中断、中断控制器中断的使能状态。</li>
<li>SSIE、STIE、SEIE这三个位域分别控制s模式下核间中断、定时中断、中断控制器中断的使能状态。</li>
</ul>
<h4 id="medeleg-和-mideleg"><a href="#medeleg-和-mideleg" class="headerlink" title="medeleg 和 mideleg"></a>medeleg 和 mideleg</h4><p>RISCV下默认所有中断和异常都是在m模式下处理的，但是有些时候我们需要将中断和异常直接交给s模式处理，这就是RISCV中的中断托管机制。通过mideleg寄存器，可以将三种中断交给s模式处理，通过medeleg寄存器，可以将异常交给s模式处理。下面来具体看看这些寄存器格式。</p>
<p>当我们想把中断交给s模式处理时，我们可以设置mideleg寄存器，这个寄存器格式如下：</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214114753859-1265781757.png" alt="img"></p>
<ul>
<li>bit[1]用于控制是否将核间中断交给s模式处理。</li>
<li>bit[5]用于控制是否将定时中断交给s模式处理。</li>
<li>bit[9]用于控制是否将中断控制器管理的中断交给s模式处理。</li>
</ul>
<p>注意对于<strong>核间中断和定时中断而言，即使使能了mideleg中对应的bit位，当产生相应中断时，还是先进入m模式进行处理，然后可以通过设置mip寄存器(下一小节讲解)，在退出m模式中断时就可以进入s模式的中断处理函数中处理。</strong></p>
<p>当我们想把异常交给s模式处理时，我们可以设置medelrg寄存器，这个寄存器格式如下：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115020818-510847302.png" alt="img"></p>
<p>可以看出来有很多异常是可以设置到s模式下处理的，但是实际使用时并不是所有异常都要交给s模式处理的，比如bit[9]代表的异常还是要交给m模式处理，因为像获取芯片id、cpu核id、设置timer等操作只能在m模式下进行，所以s模式通过SBI接口(后面会讲)使用“ecall”切换到m模式调用不同的服务，所以bit[9]代表的异常必须被m模式处理而不能交给s模式处理。</p>
<h4 id="Machine-Trap-Handling"><a href="#Machine-Trap-Handling" class="headerlink" title="Machine Trap Handling"></a>Machine Trap Handling</h4><p>当产生中断或者异常时，会有一些信息保存在相应的寄存器中，下面我们就一起来看看这些寄存器。</p>
<h4 id="mepc"><a href="#mepc" class="headerlink" title="mepc"></a>mepc</h4><p>在arm架构中，当发生中断或异常时，硬件自动将要返回的地址保存在lr寄存器中。类似的，在RISCV下产生中断或异常时，硬件自动将返回地址保存在mepc寄存器中，当在中断处理中返回时，硬件自动将mepc中的地址赋值给pc运行。</p>
<p>要注意的时，在RISCV架构中，当产生的时异常时，mepc中保存的是产生异常那条指令的地址，而不是其下一条指令地址，这么设计的原因是希望产生异常时，软件开发人员对相应异常做出处理，当处理完之后再次给一个运行之前产生异常指令的机会，比如缺页异常就是通过这种机制来运行的。当不需要再次运行产生异常那条指令时，需要在中断处理时手动将mepc的值加4，这样中断返回时就是运行产生异常那条指令的下一条指令。当产生的是中断时，mepc直接保存的就是被中断指令的下一条指令的地址，所以需要做修正。</p>
<h4 id="mcause和mtval"><a href="#mcause和mtval" class="headerlink" title="mcause和mtval"></a>mcause和mtval</h4><p>当产生中断和异常时，mcause寄存器中会记录当前产生的中断或者异常类型，而mtval则针对某些异常会记录一些辅助信息。我们来看看mcause寄存器的格式：</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115131193-1282204265.png" alt="img"> </p>
<p>寄存器的最高位用来表示产生的是中断还是异常，1表示中断0表示异常。剩下的位域表示中断或者异常的具体类型，如下所示：</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115157627-1953252108.png" alt="img"></p>
<p>可以看出来中断有6种类型，分别表示m和s模式下的定时、核间、中断控制器这三种中断，而异常的类型就比较多了。</p>
<h4 id="mip"><a href="#mip" class="headerlink" title="mip"></a>mip</h4><p>这个寄存器可以表明当前是否产生了某种中断，其格式如下所示。</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115301918-476443465.png" alt="img"> </p>
<ul>
<li><p>MSIP表示m模式核间中断，此位只读，其状态反应的是CLINT中对应的核间中断设置寄存器最低位的状态，设置CLINT核间中断设置寄存器最低位为1则产生核间中断，置0则清除核间中断。</p>
</li>
<li><p>MTIP表示m模式定时中断，此位只读，其状态通过设置CLINT中对应的mtimecmp寄存器来清零。</p>
</li>
<li><p>MEIP表示m模式中断控制器中断，此位只读，其状态通过具体的中断控制器寄存器设置来清零。</p>
</li>
<li><p>SSIP表示s模式核间中断，此位在s模式只读(s模式下有sip寄存器，下面会讲)，在m模式下可读写，通过设置此位，可以进入s模式核间中断处理。</p>
</li>
<li><p>STIP表示s模式定时中断，此位在m模式下可读写，通过设置此位，可以进入s模式定时中断处理。</p>
</li>
<li><p>SEIP表示s模式中断控制器中断<strong>，此位在m模式下可读写，通过设置此位，可以进入s模式中断控制器中断处理</strong>。</p>
</li>
</ul>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>RISC-V定义了4种中断类型，大体上和ARM架构的中断类似，中断类型选取都是通过屏蔽寄存器来控制，下面所说的由xx寄存器控制就是指由xx寄存器来负责屏蔽某种中断类型</p>
<h3 id="外部中断External-Interrupt"><a href="#外部中断External-Interrupt" class="headerlink" title="外部中断External Interrupt"></a>外部中断External Interrupt</h3><p>来自核心外的中断，常见的GPIO、UART中断都属于这个中断</p>
<p>由CSR寄存器mie中的MEIE控制，等待标志反映在CSR寄存器mip中的MEIP域</p>
<h3 id="定时器（也就是计时器）中断Timer-Interrupt"><a href="#定时器（也就是计时器）中断Timer-Interrupt" class="headerlink" title="定时器（也就是计时器）中断Timer Interrupt"></a>定时器（也就是计时器）中断Timer Interrupt</h3><p>来自定时器的中断</p>
<p>由mie寄存器的MTIE域控制，等待标志反映在mip寄存器中的MTIP域</p>
<h3 id="软件中断Software-Interrupt"><a href="#软件中断Software-Interrupt" class="headerlink" title="软件中断Software Interrupt"></a>软件中断Software Interrupt</h3><p>来自软件自己触发的中断</p>
<p>由mie寄存器中的MSIE域控制，等待标志反映在mip寄存器的MSIP域</p>
<p>RISC-V定义了一个平台级别中断控制器PLIC（Platform Level Interrupt Controller），可用于多个外部中断源的优先级仲裁和派发</p>
<p>PLIC可以将多个外部中断源仲裁为一个bit的中断信号送入处理器核，处理器核接收到中断进入异常服务程序后可以通过读PLIC的相关寄存器查看中断源的编号和信息，在处理完响应中断服务程序后可以通过写PLIC的相关九年起和外部中断源寄存器来清除中断源</p>
<p>PLIC就相当于RISC-V上的弱化版NVIC</p>
<p>RISC-V规定系统平台至少有一个定时器，并应配由2个64位寄存器mtime（反映当前定时器的计数值）和mtimecmp（设置计时器比较值），当mtime中的计数值大于等于mtimecmp中设置的比较值时，计时器就会产生计时器中断，中断期间会一直拉高直到重写mtimecmp的值大于mtime中的值</p>
<p>特别地，两个定时器寄存器不归属于CSR寄存器，而是定义为存储器地址映射的系统寄存器，由配套SoC控制，这样就使得位于内核中的定时器变成了“一半外设”</p>
<p>这个定时器的时钟必须是为低速（意味着省电）的电源常开（意味着准确稳定）的时钟，它是一种实时计时器。</p>
<h2 id="ECLIC"><a href="#ECLIC" class="headerlink" title="ECLIC"></a>ECLIC</h2><p>eclic的设计是芯来科技设计的一种中断处理方式。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/o4YBAGB31wmAUvWWAABTpScNtJw692.png" alt="2dbc5852-9d0e-11eb-8b86-12bb97331649.png"></p>
<p>eclic目前也是众多芯来科技core采用的中断控制器，也包括<a target="_blank" rel="noopener" href="https://bbs.elecfans.com/group_1508">gd32</a>vf103系列的芯片。</p>
<p>3号中断是内核TIMER单元生成的软件中断。</p>
<p>7号中断是内核TIMER单元生成的计时器中断。</p>
<p>而从19~4095中断号都是外部中断，其中断的编号与中断的优先级其实没有关系。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/o4YBAGB31wmALc2vAAKME4-z1Es208.png" alt="2dcb96f0-9d0e-11eb-8b86-12bb97331649.png"></p>
<p>而对于ECLIC的寄存器布局，可见上图。</p>
<p>cliccfg是中断全局配置寄存器，可以结合clicintctl[i]配置</p>
<p>clicinfo也是全局寄存器中的数据，对于使用上来说，是只读的</p>
<p>mth中断的阈值级别寄存器</p>
<p>clicintip[i]是中断等待寄存器，也相当于pending寄存器</p>
<p>clicintie[i]为中断使能寄存器</p>
<p>clicintattr[i]为中断的属性，可以设置中断的上升沿触发或者下降沿触发，同时也可以设置中断从处理是向量中断还是非向量中断。</p>
<p>clicintctl[i] 设置中断优先级级别和优先级，需要配合cliccfg设置阈。</p>
<h3 id="关于jalmnxti"><a href="#关于jalmnxti" class="headerlink" title="关于jalmnxti"></a>关于jalmnxti</h3><p>这个也是eclic为了减少中断延时，加速中断咬尾的自定义指令。</p>
<p>该指令是配合eclic处理机制设计的，其指令功能比较多</p>
<p>开启中断使能，处理下一个中断</p>
<p>返回下一个中断入口地址</p>
<p>跳转至中断handler</p>
<p>中断处理后返回</p>
<p>由于<a target="_blank" rel="noopener" href="http://www.elecfans.com/tags/csr/">csr</a>rw ra， CSR_JALMNXTI， ra一条指令可以达到JAL（Jump and Link）的效果，同时硬件上更新Link寄存器作为该指令的PC作为函数调用的返回值，因此从中断服务程序返回后，又会重新回到csrrw ra， CSR_JALMNXTI， ra指令再次执行，可以重新判断是否有中断pending，如果有则跳转到中断处理函数，从而实现中断的咬尾处理，如果没有中断等待，则jalmnxti实际上并不会做任何事情。</p>
<h2 id="在rt-thread中的一个中断流程"><a href="#在rt-thread中的一个中断流程" class="headerlink" title="在rt-thread中的一个中断流程"></a>在rt-thread中的一个中断流程</h2><p>在startup_cm32m4xxr.S中定义eclic_msip_hander中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.section .vtable</span><br><span class="line"></span><br><span class="line">    .weak  eclic_msip_handler   <span class="comment">// 用户级软件中断</span></span><br><span class="line">    .weak  eclic_mtip_handler </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* CM32M4xxR interrupt handlers */</span></span><br><span class="line">    .weak  WWDG_IRQHandler</span><br><span class="line">    .weak  PVD_IRQHandler</span><br><span class="line">    .weak  TAMPER_IRQHandler</span><br><span class="line">    .weak  RTC_IRQHandler</span><br><span class="line">    .weak  FLASH_IRQHandler</span><br><span class="line">    .weak  RCC_IRQHandler</span><br><span class="line">    .weak  EXTI0_IRQHandle</span><br></pre></td></tr></table></figure>

<p>中断入口函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set ECLIC non-vector entry to be controlled</span></span><br><span class="line"><span class="comment"> * by mtvt2 CSR register.</span></span><br><span class="line"><span class="comment"> * Intialize ECLIC non-vector interrupt</span></span><br><span class="line"><span class="comment"> * base address mtvt2 to irq_entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">la t0, irq_entry</span><br><span class="line">csrw CSR_MTVT2, t0</span><br><span class="line">csrs CSR_MTVT2, <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

<p>在interrupt_gcc.S中完成了中断入口函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.global irq_entry</span><br><span class="line"><span class="comment">/* This label will be set to MTVT2 register */</span></span><br><span class="line">irq_entry:</span><br><span class="line">    <span class="comment">/* Save the caller saving registers (context) */</span></span><br><span class="line">    SAVE_CONTEXT</span><br><span class="line">    <span class="comment">/* Save the necessary CSR registers */</span></span><br><span class="line">    SAVE_CSR_CONTEXT</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This special CSR read/write operation, which is actually</span></span><br><span class="line"><span class="comment">     * claim the CLIC to find its pending highest ID, if the ID</span></span><br><span class="line"><span class="comment">     * is not 0, then automatically enable the mstatus.MIE, and</span></span><br><span class="line"><span class="comment">     * jump to its vector-entry-label, and update the link register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       <span class="comment">/* 跳转到具体中断函数的语句，功能如上所述*/</span></span><br><span class="line">    csrrw ra, CSR_JALMNXTI, ra</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Critical section with interrupts disabled */</span></span><br><span class="line">    DISABLE_MIE</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore the necessary CSR registers */</span></span><br><span class="line">    RESTORE_CSR_CONTEXT</span><br><span class="line">    <span class="comment">/* Restore the caller saving registers (context) */</span></span><br><span class="line">    RESTORE_CONTEXT</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return to regular code */</span></span><br><span class="line">    mret</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Default Handler for Exceptions / Interrupts */</span></span><br></pre></td></tr></table></figure>

<p>上下文保存的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_hw_stack_frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> epc;        <span class="comment">/*!&lt; epc - epc    - program counter                     */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> ra;         <span class="comment">/*!&lt; x1  - ra     - return address for jumps            */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t0;         <span class="comment">/*!&lt; x5  - t0     - temporary register 0                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t1;         <span class="comment">/*!&lt; x6  - t1     - temporary register 1                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t2;         <span class="comment">/*!&lt; x7  - t2     - temporary register 2                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s0_fp;      <span class="comment">/*!&lt; x8  - s0/fp  - saved register 0 or frame pointer   */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s1;         <span class="comment">/*!&lt; x9  - s1     - saved register 1                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a0;         <span class="comment">/*!&lt; x10 - a0     - return value or function argument 0 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a1;         <span class="comment">/*!&lt; x11 - a1     - return value or function argument 1 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a2;         <span class="comment">/*!&lt; x12 - a2     - function argument 2                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a3;         <span class="comment">/*!&lt; x13 - a3     - function argument 3                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a4;         <span class="comment">/*!&lt; x14 - a4     - function argument 4                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a5;         <span class="comment">/*!&lt; x15 - a5     - function argument 5                 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_32e</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a6;         <span class="comment">/*!&lt; x16 - a6     - function argument 6                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a7;         <span class="comment">/*!&lt; x17 - s7     - function argument 7                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s2;         <span class="comment">/*!&lt; x18 - s2     - saved register 2                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s3;         <span class="comment">/*!&lt; x19 - s3     - saved register 3                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s4;         <span class="comment">/*!&lt; x20 - s4     - saved register 4                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s5;         <span class="comment">/*!&lt; x21 - s5     - saved register 5                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s6;         <span class="comment">/*!&lt; x22 - s6     - saved register 6                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s7;         <span class="comment">/*!&lt; x23 - s7     - saved register 7                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s8;         <span class="comment">/*!&lt; x24 - s8     - saved register 8                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s9;         <span class="comment">/*!&lt; x25 - s9     - saved register 9                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s10;        <span class="comment">/*!&lt; x26 - s10    - saved register 10                   */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s11;        <span class="comment">/*!&lt; x27 - s11    - saved register 11                   */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t3;         <span class="comment">/*!&lt; x28 - t3     - temporary register 3                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t4;         <span class="comment">/*!&lt; x29 - t4     - temporary register 4                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t5;         <span class="comment">/*!&lt; x30 - t5     - temporary register 5                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t6;         <span class="comment">/*!&lt; x31 - t6     - temporary register 6                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">rt_ubase_t</span> mstatus;    <span class="comment">/*!&lt;              - machine status register             */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们新建一个线程，初始化线程时，会为其开辟一个线程栈（程序中通常设置一个数组），即对上述结构体做初始化，在rt-thread中的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> _rt_thread_init(<span class="keyword">struct</span> rt_thread *thread,</span><br><span class="line">                                <span class="type">const</span> <span class="type">char</span>       *name,</span><br><span class="line">                                <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span><br><span class="line">                                <span class="type">void</span>             *parameter,</span><br><span class="line">                                <span class="type">void</span>             *stack_start,</span><br><span class="line">                                <span class="type">rt_uint32_t</span>       stack_size,</span><br><span class="line">                                <span class="type">rt_uint8_t</span>        priority,</span><br><span class="line">                                <span class="type">rt_uint32_t</span>       tick)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init thread list */</span></span><br><span class="line">    rt_list_init(&amp;(thread-&gt;tlist));</span><br><span class="line"></span><br><span class="line">    thread-&gt;entry = (<span class="type">void</span> *)entry;</span><br><span class="line">    thread-&gt;parameter = parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stack init */</span></span><br><span class="line">    thread-&gt;stack_addr = stack_start;</span><br><span class="line">    thread-&gt;stack_size = stack_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread stack */</span></span><br><span class="line">    rt_memset(thread-&gt;stack_addr, <span class="string">&#x27;#&#x27;</span>, thread-&gt;stack_size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARCH_CPU_STACK_GROWS_UPWARD</span></span><br><span class="line">    thread-&gt;sp = (<span class="type">void</span> *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,</span><br><span class="line">                                          (<span class="type">void</span> *)((<span class="type">char</span> *)thread-&gt;stack_addr),</span><br><span class="line">                                          (<span class="type">void</span> *)rt_thread_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    thread-&gt;sp = (<span class="type">void</span> *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,</span><br><span class="line">                                          (<span class="type">rt_uint8_t</span> *)((<span class="type">char</span> *)thread-&gt;stack_addr + thread-&gt;stack_size - <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>)),</span><br><span class="line">                                          (<span class="type">void</span> *)rt_thread_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	............</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">rt_uint8_t</span> *<span class="title function_">rt_hw_stack_init</span><span class="params">(<span class="type">void</span>       *tentry,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint8_t</span> *stack_addr,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *texit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_hw_stack_frame</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>         *stk;</span><br><span class="line">    <span class="type">int</span>                i;</span><br><span class="line"></span><br><span class="line">    stk  = stack_addr + <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>);</span><br><span class="line">    stk  = (<span class="type">rt_uint8_t</span> *)RT_ALIGN_DOWN((<span class="type">rt_ubase_t</span>)stk, REGBYTES);</span><br><span class="line">    stk -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_hw_stack_frame);</span><br><span class="line"></span><br><span class="line">    frame = (<span class="keyword">struct</span> rt_hw_stack_frame *)stk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_hw_stack_frame) / <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ((<span class="type">rt_ubase_t</span> *)frame)[i] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;ra      = (<span class="type">rt_ubase_t</span>)texit;</span><br><span class="line">    frame-&gt;a0      = (<span class="type">rt_ubase_t</span>)parameter;</span><br><span class="line">    frame-&gt;epc     = (<span class="type">rt_ubase_t</span>)tentry;</span><br><span class="line"></span><br><span class="line">    frame-&gt;mstatus = RT_INITIAL_MSTATUS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从堆栈初始化程序*rt_hw_stack_init中可以看出，其先将堆栈顶部地址对齐，然后向下偏移一个rt_hw_stack_frame结构体的大小，用于存储图1中需要存储的寄存器，并对该部分空间进行了初始化。其中把线程的入口地址给了mepc，线程输入参数给a0，mstatus初始值（MPP、MPIE、FS、MIE），即强制机器模式，使能浮点，MPIE为1，MIE为0。如果不带硬件浮点，可将该值设置为0x1880。另外设置ra为线程的返回地址，一般情况下一个线程我们希望一直运行的，当需要返回时说明该线程不再需要运行，所以返回地址一般是一段将该线程从线程列表中删除并切换至下一个线程的一段程序，即上面中调用的函数_rt_thread_exit。</p>
<p><strong>rt-thread的详细的启动流程。</strong>rt-thread定义一个rt_thread类型的全局指针rt_current_thread，用于实时获取当前运行的线程。从图9可知，硬件启动后进rtthread_startup，其开始进行了必要的初始化，如系统滴答定时器、堆、串口、调度器、定时器、main线程、空闲idle线程等等，最后执行了rt_system_scheduler_start后转交调度器执行。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/image-20221028110054550.png" alt="image-20221028110054550"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/image-20221028110132550.png" alt="image-20221028110132550"></p>
<p>由图2可知，其会查找优先级较高的就绪组优先级，并根据该优先级查找就绪链表，获取优先级较高的任务并得到控制块to_thread，然后调用rt_hw_context_switch_to切换至该任务。其是一段汇编实现的代码，传入的参数为该任务的sp指针。由前文可知，我们可以根据to_thread-&gt;sp得到该任务的堆栈位置，该堆栈的顶部空间存储了执行该任务时cpu寄存器的值，由此也可推测该部分汇编代码主要完成的就是从sp处恢复cpu寄存器值，并转而执行该任务。其代码如下图3所示，详见注释。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/v2-2a3cd8c82045fccaf5b278e5d1c3a759_1440w.webp" alt="img"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/v2-3672e11c8f2cc78763d2f598bc1c0ac9_1440w.webp" alt="img"></p>
<p>由上注释分析可知，rt_hw_context_switch_to通过传入的sp，恢复cpu寄存器，其中mepc寄存器任务初始化时设置为任务的入口地址，ra寄存器设置为返回地址，其指向公用函数_rt_thread_exit。当mret返回后，pc更新为mepc值，即转向执行任务函数，若其不是一个持续执行的[while(1)]函数，那么其返回至_rt_thread_exit，删除该任务，并切换至其他任务。由此也可理解图2中，最后一句注释“never come back”的含义了，一旦开始执行任务，pc值被改变，再不会回到调用的地方。</p>
<p>rt_schedule()函数切换上下文的过程，则是挂起一个中断，然后在中断服务函数中实现上下文切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_hw_context_switch</span><span class="params">(<span class="type">rt_ubase_t</span> from, <span class="type">rt_ubase_t</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rt_thread_switch_interrupt_flag == <span class="number">0</span>)</span><br><span class="line">        rt_interrupt_from_thread = from;</span><br><span class="line"></span><br><span class="line">    rt_interrupt_to_thread = to;</span><br><span class="line">    rt_thread_switch_interrupt_flag = <span class="number">1</span>;</span><br><span class="line">    RT_YIELD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler utilities. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_YIELD()                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Set a software interrupt(SWI) request to request a context switch. */</span>    \</span></span><br><span class="line"><span class="meta">    SysTimer_SetSWIRQ();                                                        \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Barriers are normally not required but do ensure the code is completely  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    within the specified behaviour for the architecture. */</span>                     \</span></span><br><span class="line"><span class="meta">    __RWMB();                                                                   \</span></span><br><span class="line"><span class="meta">    __FENCE_I();                                                                \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">__STATIC_FORCEINLINE <span class="type">void</span> <span class="title function_">SysTimer_SetSWIRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hartid = __RV_CSR_READ(CSR_MHARTID);</span><br><span class="line">    <span class="keyword">if</span> (hartid == <span class="number">0</span>) &#123;</span><br><span class="line">        SysTimer-&gt;MSIP |= SysTimer_MSIP_MSIP_Msk;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *addr = (<span class="type">uint8_t</span> *)(SysTimer_CLINT_MSIP_BASE(hartid));</span><br><span class="line">        __SW(addr, SysTimer_MSIP_MSIP_Msk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断服务函数实体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">.global eclic_msip_handler</span><br><span class="line">eclic_msip_handler:</span><br><span class="line">    addi sp, sp, -RT_CONTEXT_SIZE</span><br><span class="line">    STORE x1,  <span class="number">1</span>  * REGBYTES(sp)    <span class="comment">/* RA */</span></span><br><span class="line">    STORE x5,  <span class="number">2</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x6,  <span class="number">3</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x7,  <span class="number">4</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x8,  <span class="number">5</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x9,  <span class="number">6</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x10, <span class="number">7</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x11, <span class="number">8</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x12, <span class="number">9</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x13, <span class="number">10</span> * REGBYTES(sp)</span><br><span class="line">    STORE x14, <span class="number">11</span> * REGBYTES(sp)</span><br><span class="line">    STORE x15, <span class="number">12</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_32e</span></span><br><span class="line">    STORE x16, <span class="number">13</span> * REGBYTES(sp)</span><br><span class="line">    STORE x17, <span class="number">14</span> * REGBYTES(sp)</span><br><span class="line">    STORE x18, <span class="number">15</span> * REGBYTES(sp)</span><br><span class="line">    STORE x19, <span class="number">16</span> * REGBYTES(sp)</span><br><span class="line">    STORE x20, <span class="number">17</span> * REGBYTES(sp)</span><br><span class="line">    STORE x21, <span class="number">18</span> * REGBYTES(sp)</span><br><span class="line">    STORE x22, <span class="number">19</span> * REGBYTES(sp)</span><br><span class="line">    STORE x23, <span class="number">20</span> * REGBYTES(sp)</span><br><span class="line">    STORE x24, <span class="number">21</span> * REGBYTES(sp)</span><br><span class="line">    STORE x25, <span class="number">22</span> * REGBYTES(sp)</span><br><span class="line">    STORE x26, <span class="number">23</span> * REGBYTES(sp)</span><br><span class="line">    STORE x27, <span class="number">24</span> * REGBYTES(sp)</span><br><span class="line">    STORE x28, <span class="number">25</span> * REGBYTES(sp)</span><br><span class="line">    STORE x29, <span class="number">26</span> * REGBYTES(sp)</span><br><span class="line">    STORE x30, <span class="number">27</span> * REGBYTES(sp)</span><br><span class="line">    STORE x31, <span class="number">28</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Push mstatus to stack */</span></span><br><span class="line">    csrr t0, CSR_MSTATUS</span><br><span class="line">    STORE t0,  (RT_SAVED_REGNUM - <span class="number">1</span>)  * REGBYTES(sp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Push additional registers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store sp to task stack */</span></span><br><span class="line">    LOAD t0, rt_interrupt_from_thread</span><br><span class="line">    STORE sp, <span class="number">0</span>(t0)</span><br><span class="line"></span><br><span class="line">    csrr t0, CSR_MEPC</span><br><span class="line">    STORE t0, <span class="number">0</span>(sp)</span><br><span class="line"></span><br><span class="line">    jal rt_hw_taskswitch</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch task context */</span></span><br><span class="line">    LOAD t0, rt_interrupt_to_thread</span><br><span class="line">    LOAD sp, <span class="number">0x0</span>(t0)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop PC from stack and set MEPC */</span></span><br><span class="line">    LOAD t0,  <span class="number">0</span>  * REGBYTES(sp)</span><br><span class="line">    csrw CSR_MEPC, t0</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop additional registers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop mstatus from stack and set it */</span></span><br><span class="line">    LOAD t0,  (RT_SAVED_REGNUM - <span class="number">1</span>)  * REGBYTES(sp)</span><br><span class="line">    csrw CSR_MSTATUS, t0</span><br><span class="line">    <span class="comment">/* Interrupt still disable here */</span></span><br><span class="line">    <span class="comment">/* Restore Registers from Stack */</span></span><br><span class="line">    LOAD x1,  <span class="number">1</span>  * REGBYTES(sp)    <span class="comment">/* RA */</span></span><br><span class="line">    LOAD x5,  <span class="number">2</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x6,  <span class="number">3</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x7,  <span class="number">4</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x8,  <span class="number">5</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x9,  <span class="number">6</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x10, <span class="number">7</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x11, <span class="number">8</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x12, <span class="number">9</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x13, <span class="number">10</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x14, <span class="number">11</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x15, <span class="number">12</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_32e</span></span><br><span class="line">    LOAD x16, <span class="number">13</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x17, <span class="number">14</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x18, <span class="number">15</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x19, <span class="number">16</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x20, <span class="number">17</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x21, <span class="number">18</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x22, <span class="number">19</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x23, <span class="number">20</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x24, <span class="number">21</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x25, <span class="number">22</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x26, <span class="number">23</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x27, <span class="number">24</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x28, <span class="number">25</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x29, <span class="number">26</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x30, <span class="number">27</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x31, <span class="number">28</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    addi sp, sp, RT_CONTEXT_SIZE</span><br><span class="line">    mret</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/" data-id="cl9rwxhuj0000rgmjfkqo7gpe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构位图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/" class="article-date">
  <time datetime="2022-10-24T01:57:27.000Z" itemprop="datePublished">2022-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/">数据结构位图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>一个字节可以用来存储8个连续的整数，一个整数4个字节的话，当要存储40亿个整数时，按之前数组存储的方式需要大概16G的内存，显然不合理。使用位图的话，只需要500M的内存。</p>
<p>位图初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitmap(<span class="type">int</span> size)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">	<span class="built_in">memset</span>(arr,<span class="number">0</span>,(size&gt;&gt;<span class="number">32</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）"><a href="#1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）" class="headerlink" title="1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）"></a>1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index = N &gt;&gt;<span class="number">5</span>;  <span class="comment">// 一个int类型的数据可以存储32个连续的整数，右移5位相当于除以32</span></span><br><span class="line">num = N %<span class="number">32</span>;    <span class="comment">// num &amp; 31</span></span><br></pre></td></tr></table></figure>

<h3 id="2、将位置x置位1"><a href="#2、将位置x置位1" class="headerlink" title="2、将位置x置位1"></a>2、将位置x置位1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据在内存中按小端方式存放</span></span><br><span class="line">arr[index] |= (<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-num))  <span class="comment">// &amp;31 相当于 %32 因为 31的2进制数为0x1111</span></span><br></pre></td></tr></table></figure>

<h3 id="3、将x位置上的数字清空"><a href="#3、将x位置上的数字清空" class="headerlink" title="3、将x位置上的数字清空"></a>3、将x位置上的数字清空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[index] &amp;=~(<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-num))</span><br></pre></td></tr></table></figure>

<h3 id="4、判断位图中是否包含这个数"><a href="#4、判断位图中是否包含这个数" class="headerlink" title="4、判断位图中是否包含这个数"></a>4、判断位图中是否包含这个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[index] &amp; (<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-num)) !=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="rt-thread中的位图优先级"><a href="#rt-thread中的位图优先级" class="headerlink" title="rt-thread中的位图优先级"></a>rt-thread中的位图优先级</h2><p><img src="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/image-20221107133426982.png" alt="image-20221107133426982"></p>
<p><img src="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/image-20221107133505042.png" alt="image-20221107133505042"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">INT8U  <span class="type">const</span>  OSUnMapTbl[<span class="number">256</span>] = &#123; </span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x00 to 0x0F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x10 to 0x1F                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x20 to 0x2F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x30 to 0x3F                             */</span></span><br><span class="line">  <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x40 to 0x4F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x50 to 0x5F                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x60 to 0x6F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x70 to 0x7F                             */</span></span><br><span class="line">  <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x80 to 0x8F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x90 to 0x9F                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xA0 to 0xAF                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xB0 to 0xBF                             */</span></span><br><span class="line">  <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xC0 to 0xCF                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xD0 to 0xDF                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xE0 to 0xEF                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>        <span class="comment">/* 0xF0 to 0xFF                             */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __rt_ffs(<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp; <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">return</span> __lowest_bit_bitmap[value &amp; <span class="number">0xff</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp; <span class="number">0xff00</span>)</span><br><span class="line">        <span class="keyword">return</span> __lowest_bit_bitmap[(value &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>] + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp; <span class="number">0xff0000</span>)</span><br><span class="line">        <span class="keyword">return</span> __lowest_bit_bitmap[(value &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>] + <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __lowest_bit_bitmap[(value &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>] + <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/" data-id="cl9m644td00012omje6i22zzx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-riscv汇编语言编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/21/riscv%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2022-10-21T05:40:27.000Z" itemprop="datePublished">2022-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/21/riscv%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/">riscv汇编语言编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><strong>一个完整的risc-v汇编程序是由多条语句(statment)构成的</strong></p>
</li>
<li><p><strong>一条典型的RISC-V汇编语句是由3部分组成的：</strong></p>
<p>[label:] [operation] [comment]</p>
</li>
<li><p><strong>label(标号)：GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号</strong></p>
</li>
<li><p><strong>operation 可以有以下多种类型：</strong></p>
<p><strong>instruction(指令)</strong>: 直接应对二进制机器指令的字符串</p>
<p>**pseudo-instruction(伪指令)**：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令(instructions)</p>
<p>**directive(指示/伪操作)**：通过类似指令的形式（”.”开头），通知汇编器如何控制代码的产生，不对应具体的指令。</p>
<p>**macro:**采用.marco/.endm 自定义宏</p>
</li>
</ul>
<h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h3><p>​    32个通用寄存器，x0-x31</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/21/riscv%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" data-id="cl9m644ta00002omj6j6h78w8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/12/07/csapp-ShellLab%E5%AE%9E%E9%AA%8C/">csapp:ShellLab实验</a>
          </li>
        
          <li>
            <a href="/2022/12/02/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%81%E8%A3%85/">线程同步机制的封装</a>
          </li>
        
          <li>
            <a href="/2022/11/28/qemu%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/">qemu相关配置参数</a>
          </li>
        
          <li>
            <a href="/2022/11/24/epoll%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8/">epoll实现一个简易服务器</a>
          </li>
        
          <li>
            <a href="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/">编译nuclei-qemu</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>