<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-编译nuclei-qemu" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/" class="article-date">
  <time datetime="2022-11-15T05:26:16.000Z" itemprop="datePublished">2022-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/">编译nuclei-qemu</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Windows-上编译qemu"><a href="#Windows-上编译qemu" class="headerlink" title="Windows 上编译qemu"></a>Windows 上编译qemu</h2><h3 id="1、安装msys2"><a href="#1、安装msys2" class="headerlink" title="1、安装msys2"></a>1、安装msys2</h3><p>msys2官网网址<a target="_blank" rel="noopener" href="http://www.msys2.org/">http://www.msys2.org/</a></p>
<h3 id="2、运行msys2-exe"><a href="#2、运行msys2-exe" class="headerlink" title="2、运行msys2.exe"></a>2、运行msys2.exe</h3><p>a.) 执行pacman -Syu更新系统到最新，更新完后系统会要求重启，关掉msys2 shell.</p>
<p>b.)重新启动msys2.exe<br>   执行pacman -Su，看是否还有更新，如果有则更新。</p>
<h3 id="3、替换软件源"><a href="#3、替换软件源" class="headerlink" title="3、替换软件源"></a>3、替换软件源</h3><p>配置一下pacman使用清华大学的<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=%5Bhttps://mirror.tuna.tsinghua.edu.cn/help/msys2/%5D(https://mirror.tuna.tsinghua.edu.cn/help/msys2/)">镜像</a>（PS：其实安装包也可以从清华大学镜像站中下载）。修改方法如下：</p>
<p>编辑 <code>/etc/pacman.d/mirrorlist.mingw32</code> ，在文件开头添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/msys2/mingw/i686</span></span><br></pre></td></tr></table></figure>

<p>编辑 <code>/etc/pacman.d/mirrorlist.mingw64</code> ，在文件开头添加：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64</span></span><br></pre></td></tr></table></figure>

<p>编辑 <code>/etc/pacman.d/mirrorlist.msys</code> ，在文件开头添加：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server = <span class="symbol">https:</span>/<span class="regexp">/mirrors.tuna.tsinghua.edu.cn/msys</span>2/msys/$arch</span><br></pre></td></tr></table></figure>

<p>然后执行<code>pacman -Syu</code>刷新软件包并且更新mysys2系统组件即可，然后重启shell。</p>
<p>上面的/etc/是指mysys的安装目录下的etc目录。</p>
<p><strong>安装ninja</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ninja-build/ninja.git</span><br><span class="line">./configure.py --bootstrap   #在ninja目录中执行</span><br><span class="line">cp ./ninja  /usr/bin  #在ninja目录中执行，这样即可任意位置使用ninja</span><br><span class="line">ninja --version</span><br></pre></td></tr></table></figure>

<h3 id="4、快速安装所有mingw"><a href="#4、快速安装所有mingw" class="headerlink" title="4、快速安装所有mingw"></a>4、快速安装所有mingw</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S  mingw-w64-i686-toolchain</span><br><span class="line">pacman -S  mingw-w64-x86_64-toolchain</span><br></pre></td></tr></table></figure>

<h3 id="5、msys2启动入口"><a href="#5、msys2启动入口" class="headerlink" title="5、msys2启动入口"></a>5、msys2启动入口</h3><p>安装Msys2后，或解压Msys2后，第一次运行下msys2_shell.cmd，提示第一次设置初始化完毕后，就可以运行Msys2.exe、mingw64.exe或mingw32.exe，主要区别：</p>
<ul>
<li>mingw32 优先使用 msys64/mingw32 下的工具;</li>
<li>mingw64 优先使用 msys64/mingw64 下的工具;</li>
<li>msys2 两个都不使用，只用自身 msys 的工具;82</li>
</ul>
<h3 id="6、其它常用软件或库"><a href="#6、其它常用软件或库" class="headerlink" title="6、其它常用软件或库"></a>6、其它常用软件或库</h3><p><code>pacman -S base-devel git wget p7zip perl ruby python2</code> ，不过有些上面安装过程中已经安装了。</p>
<h3 id="7、拉取nuclei-qemu源代码"><a href="#7、拉取nuclei-qemu源代码" class="headerlink" title="7、拉取nuclei-qemu源代码"></a>7、拉取nuclei-qemu源代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone -b plct-nuclei-rebase https://github.com/plctlab/plct-qemu.git</span><br><span class="line">cd plct-nuclei</span><br><span class="line">mkdir build </span><br><span class="line">cd build</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update --remote --recursive</span><br></pre></td></tr></table></figure>

<p>只编译riscv32位的qemu，在configure中指定target-list=riscv32-softmmu</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">../configure --target-list=riscv32-softmmu --disable-werror</span><br><span class="line">make -j8</span><br></pre></td></tr></table></figure>

<h3 id="8、验证qemu编译是否成功"><a href="#8、验证qemu编译是否成功" class="headerlink" title="8、验证qemu编译是否成功"></a>8、验证qemu编译是否成功</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-riscv32.exe --version</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QEMU emulator version 5.2.90 (v5.0.0-rc2-9705-geaabfc7ea0)</span><br><span class="line">Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure>

<p>说明编译成功，但是此时的qemu在用图形化界面时，会发生错误，因为它依赖于mingw64的环境，缺少了一些dll库，将msys2根目录下的mingw64的bin目录下的文件全部复制到qemu-system-riscv32的同级目录下，即可运行。</p>
<p><img src="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/image-20221115135341921.png" alt="image-20221115135341921"></p>
<h3 id="9、使用nuclei-qemu运行helloworld例程"><a href="#9、使用nuclei-qemu运行helloworld例程" class="headerlink" title="9、使用nuclei-qemu运行helloworld例程"></a>9、使用nuclei-qemu运行helloworld例程</h3><p>例程是nuclei studio上的helloworld程序，可以通过nuclei ide的qemu上运行的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M ?</span><br><span class="line">Supported machines are:</span><br><span class="line">gd32vf103_eval       RISC-V Nuclei GD32VF103 Eval Board</span><br><span class="line">gd32vf103_rvstar     RISC-V Nuclei GD32VF103 Rvstar Board</span><br><span class="line">hbird_fpga           Nuclei HummingBird Evaluation Kit</span><br><span class="line">none                 empty machine</span><br><span class="line">opentitan            RISC-V Board compatible with OpenTitan</span><br><span class="line">sifive_e             RISC-V Board compatible with SiFive E SDK</span><br><span class="line">sifive_u             RISC-V Board compatible with SiFive U SDK</span><br><span class="line">spike                RISC-V Spike board (default)</span><br><span class="line">virt                 RISC-V VirtIO board</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M gd32vf103_eval -nographic -kernel 5_helloworld.elf</span><br><span class="line">Nuclei SDK Build Time: Nov 15 2022, 10:26:49</span><br><span class="line">Download Mode: FLASHXIP</span><br><span class="line">CPU Frequency 269500000 Hz</span><br><span class="line">Hart 0, MISA: 0x40101105</span><br><span class="line">MISA: RV32IMACU</span><br><span class="line">0: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">1: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">2: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">3: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">4: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">5: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">6: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">7: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">8: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">9: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">10: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">11: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">12: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">13: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">14: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">15: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">16: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">17: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">18: Hello World From Nuclei RISC-V Processor!</span><br><span class="line">19: Hello World From Nuclei RISC-V Processor!</span><br></pre></td></tr></table></figure>

<p>在ide中其实就是给qemu发送了命令，实现的<strong>运行仿真</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M gd32vf103_eval -nographic -kernel 5_helloworld.elf</span><br></pre></td></tr></table></figure>

<p>  -M：指定模拟哪个目标板，这个一定得是qemu支持的，否则会提示错误。从上面我们可以知道，RT-Thread的生态里qemu是支持了这个stm32f407-atk-explorer板子的了</p>
<p>-nographic：告诉qemu无界面启动（因为默认有一个类似VMware那样的界面），这个非常重要，这样程序中串口打印信息（printf）才能输出到控制台来，否则不会有任何输出。（qemu help的解释：-nographic      disable graphical output and redirect serial I/Os to console），所以我们别去调用什么-serial stdio啥的命令，否则也不会输出。</p>
<p>-kernel：指定程序镜像文件，这个可以是bin文件，elf文件（含有调试信息）都可以<br>如果是<strong>调试仿真</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\mysys2\home\Administrator\plct-qemu\build\qemu-system-riscv32.exe -M gd32vf103_eval -nographic -S -s -kernel 5_helloworld.elf</span><br></pre></td></tr></table></figure>

<p>-S：代表不自动运行模拟（需要gdb连接之后进行操作）</p>
<p>-s：代表开放tcp1234作为远程调试端口</p>
<p>nuclei-studio中有关qemu的配置</p>
<p><img src="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/image-20221115140543751.png" alt="image-20221115140543751"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/" data-id="clahtazjr00008kmjfoowgfhv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-spike相关理解1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/" class="article-date">
  <time datetime="2022-11-03T08:36:54.000Z" itemprop="datePublished">2022-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/">spike相关理解1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="spike整体结构"><a href="#spike整体结构" class="headerlink" title="spike整体结构"></a>spike整体结构</h2><ul>
<li><strong>fdt</strong>：为模拟器生成device tree，包括cpu数量，内存的大小等</li>
<li><strong>fesvr</strong>：提供了target与主机host交互的接口（借助proxy kernel实现，pk处理application代码中的系统调用，但是实际上要导到host os中进行处理，他们之间就是通过fesvr来进行通信的）</li>
<li><strong>softfloat库提供了浮点数的支持</strong></li>
<li><strong>riscv实现了risc-v机器码的翻译和执行</strong></li>
<li>spike_main: 程序的entry_point和interface</li>
</ul>
<h2 id="spike模拟器执行binary的流程"><a href="#spike模拟器执行binary的流程" class="headerlink" title="spike模拟器执行binary的流程"></a>spike模拟器执行binary的流程</h2><ul>
<li>解码，将机器码要翻译成指令</li>
<li>memory load and store  维护内存</li>
<li>maintain register 维护寄存器</li>
<li>debug mode — like a tiny gdb 提供一个接口类似于gdb</li>
<li>执行指令</li>
</ul>
<h2 id="Spike-CPU的指令执⾏过程"><a href="#Spike-CPU的指令执⾏过程" class="headerlink" title="Spike CPU的指令执⾏过程"></a><strong>Spike CPU</strong>的指令执⾏过程</h2><ul>
<li><p> Spike执⾏代码时，执⾏的实际上是C++ Function</p>
</li>
<li><p> CPU从pc指针处读取指令，通过译码来确定接下来要执⾏的功能 </p>
</li>
<li><p> 指令的⾏为定义在riscv/insns下的 指令名称.h⽂件中</p>
</li>
<li><p>指令的编码定义在riscv/encoding.h中</p>
<p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103165247326.png" alt="image-20221103165247326"></p>
</li>
<li><p> 定义⼀条指令需要定义如下内容：</p>
</li>
<li><p> #defifine MATCH_[instruction name] 0x12341234  // 指令的操作码</p>
</li>
<li><p> #defifine MASK_[instruction name] 0xabcdabcd  //指令的掩码，把不需要的不是参数的位置为一可以起到屏蔽作用</p>
</li>
<li><p> DECLARE_INSN(XXX, MATCH_XXX, MASK_XXX) // 将指令函数，指令操作码，指令掩码联系在一起</p>
</li>
<li><p> alternative：通过riscv-opcodes⽣成encoding.h</p>
</li>
</ul>
<p> 例：riscv/insns/lw.h</p>
<p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103170520594.png" alt="image-20221103170520594"></p>
<p>实际上模拟指令的⾏为相当于写对应的c++ function</p>
<p> riscv/decode.h中定义了⼀系列操作存储器和寄存器的宏定义，以便于在指令中操作它们</p>
<h2 id="fesvr-模块简介"><a href="#fesvr-模块简介" class="headerlink" title="fesvr 模块简介"></a><strong>fesvr</strong> <strong>模块简介</strong></h2><ul>
<li> <strong>fesvr， 全称是 risc-v front-end server</strong></li>
<li>主要用来实现simulation target 与host 主机的交互</li>
</ul>
<p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103171413134.png" alt="image-20221103171413134"></p>
<p>spike并没有模拟外部设备，所以需要I/O会产生中断，用host os处理。 htif 全称 host target interface。</p>
<h2 id="Spike-启动simulation的过程"><a href="#Spike-启动simulation的过程" class="headerlink" title="Spike 启动simulation的过程"></a><strong>Spike</strong> <strong>启动simulation</strong>的过程</h2><p><img src="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/image-20221103171954856.png" alt="image-20221103171954856"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/" data-id="cla0we55t00009cmj5sj4ecku" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qemu新增Soc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/" class="article-date">
  <time datetime="2022-11-02T05:25:32.000Z" itemprop="datePublished">2022-11-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/">qemu新增Soc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RISC-V模拟器分类"><a href="#RISC-V模拟器分类" class="headerlink" title="RISC-V模拟器分类"></a>RISC-V模拟器分类</h2><p>• Functional(QEMU)：采⽤⼆进制翻译，实际执⾏的是翻译之后的机器码，执⾏效率⾼</p>
<p>• Trace-accurate(Spike) :模拟实际代码执⾏过程中的软硬件⾏为，提供指令级别的仿真</p>
<p>• Cycle-accurate：提供硬件级别的仿真，可以针对特定的实现作周期级别的模拟</p>
<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102144255567.png" alt="image-20221102144255567"></p>
<h2 id="qemu基本结构"><a href="#qemu基本结构" class="headerlink" title="qemu基本结构"></a>qemu基本结构</h2><p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221103175755756.png" alt="image-20221103175755756"></p>
<h2 id="QEMU中Soc的添加"><a href="#QEMU中Soc的添加" class="headerlink" title="QEMU中Soc的添加"></a>QEMU中Soc的添加</h2><p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221107105900475.png" alt="image-20221107105900475"></p>
<h3 id="Cpu模拟"><a href="#Cpu模拟" class="headerlink" title="Cpu模拟"></a>Cpu模拟</h3><p>QOM模型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyDevice</span>&#123;</span></span><br><span class="line">	DeviceState parent;   <span class="comment">// 父设备</span></span><br><span class="line">	<span class="type">int</span> reg0,reg1;</span><br><span class="line">&#125;MyDevice</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyDeviceClass</span>&#123;</span></span><br><span class="line">    DeviceClass parent; </span><br><span class="line">    <span class="type">void</span> (*init)(MyDevice *obj);    </span><br><span class="line">&#125;MyDeviceClass;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_device_register_types</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    type_register_static(&amp;my_device_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(my_device_register_types);</span><br></pre></td></tr></table></figure>

<p>Risc-V cpu：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RISCVCPU</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    CPUState parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    CPUNegativeOffsetState neg; </span><br><span class="line">    CPURISCVState env;  <span class="comment">//存储riscv cpu相关的寄存器和上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configuration Settings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">bool</span> ext_i;</span><br><span class="line">        <span class="type">bool</span> ext_e;</span><br><span class="line">        <span class="type">bool</span> ext_g;</span><br><span class="line">        <span class="type">bool</span> ext_m;</span><br><span class="line">        <span class="type">bool</span> ext_a;</span><br><span class="line">        <span class="type">bool</span> ext_f;</span><br><span class="line">        <span class="type">bool</span> ext_d;</span><br><span class="line">        <span class="type">bool</span> ext_c;</span><br><span class="line">        <span class="type">bool</span> ext_s;</span><br><span class="line">        <span class="type">bool</span> ext_u;</span><br><span class="line">        <span class="type">bool</span> ext_h;</span><br><span class="line">        <span class="type">bool</span> ext_counters;</span><br><span class="line">        <span class="type">bool</span> ext_ifencei;</span><br><span class="line">        <span class="type">bool</span> ext_icsr;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> *priv_spec;</span><br><span class="line">        <span class="type">char</span> *user_spec;</span><br><span class="line">        <span class="type">bool</span> mmu;</span><br><span class="line">        <span class="type">bool</span> pmp;</span><br><span class="line">    &#125; cfg;</span><br><span class="line">&#125; RISCVCPU;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RISCVCPUClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    CPUClass parent_class;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">    DeviceRealize parent_realize;</span><br><span class="line">    DeviceReset parent_reset;</span><br><span class="line">&#125; RISCVCPUClass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*相关寄存器的一些操作*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_priv_version</span><span class="params">(CPURISCVState *env, <span class="type">int</span> priv_ver)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;priv_ver = priv_ver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_feature</span><span class="params">(CPURISCVState *env, <span class="type">int</span> feature)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;features |= (<span class="number">1ULL</span> &lt;&lt; feature);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">set_resetvec</span><span class="params">(CPURISCVState *env, <span class="type">int</span> resetvec)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_USER_ONLY</span></span><br><span class="line">    env-&gt;resetvec = resetvec;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">riscv_any_cpu_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    CPURISCVState *env = &amp;RISCV_CPU(obj)-&gt;env;</span><br><span class="line">    set_misa(env, RVXLEN | RVI | RVM | RVA | RVF | RVD | RVC | RVU);</span><br><span class="line">    set_priv_version(env, PRIV_VERSION_1_11_0);</span><br><span class="line">    set_resetvec(env, DEFAULT_RSTVEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*cpu 注册*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo riscv_cpu_type_infos[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        .name = TYPE_RISCV_CPU,</span><br><span class="line">        .parent = TYPE_CPU,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(RISCVCPU),</span><br><span class="line">        .instance_init = riscv_cpu_init,</span><br><span class="line">        .abstract = <span class="literal">true</span>,</span><br><span class="line">        .class_size = <span class="keyword">sizeof</span>(RISCVCPUClass),</span><br><span class="line">        .class_init = riscv_cpu_class_init,</span><br><span class="line">    &#125;,</span><br><span class="line">    DEFINE_CPU(TYPE_RISCV_CPU_ANY,              riscv_any_cpu_init),</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(TARGET_RISCV32)</span></span><br><span class="line">   	。。。。。。。。。</span><br><span class="line">    DEFINE_CPU(TYPE_RISCV_CPU_NUCLEI_N307,    rv32imafcu_nuclei_cpu_init),</span><br><span class="line">    。。。。。。。。。</span><br><span class="line">    <span class="comment">/* Depreacted */</span></span><br><span class="line">   	。。。。。。。。。</span><br><span class="line">    DEFINE_CPU(TYPE_RISCV_CPU_RV64GCSU_V1_10_0, rv64gcsu_priv1_10_0_cpu_init)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DEFINE_TYPES(riscv_cpu_type_infos)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RISCV-CPU-指令扩展"><a href="#RISCV-CPU-指令扩展" class="headerlink" title="RISCV  CPU 指令扩展"></a>RISCV  CPU 指令扩展</h3><h3 id="RISCV-SOC-CSR扩展"><a href="#RISCV-SOC-CSR扩展" class="headerlink" title="RISCV SOC CSR扩展"></a>RISCV SOC CSR扩展</h3><p>qemu已经支持了csrrw，csrrs等相关的指令了，只需要调用相关的trans_csrrw等函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrw</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrs</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrc</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">trans_csrrwi</span><span class="params">(DisasContext *ctx,arg_csrrw *a)</span>;</span><br></pre></td></tr></table></figure>

<p>target/riscv/cpu_bits.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCH        0x340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MEPC            0x341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MCAUSE          0x342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MTVAL           0x343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MIP             0x344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MNXTI             0x345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MINTSTATUS        0x346</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCHCSW        0x348</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSR_MSCRATCHCSWL        0x349</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>target/riscv/csr.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_mmisc_ctl</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *val = env-&gt;mmisc_ctl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_mmisc_ctl</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong val)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;mmisc_ctl = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_msavestatus</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong *val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *val = env-&gt;msavestatus;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_msavestatus</span><span class="params">(CPURISCVState *env, <span class="type">int</span> csrno, target_ulong val)</span></span><br><span class="line">&#123;</span><br><span class="line">    env-&gt;msavestatus = val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">MemmapEntry</span> &#123;</span></span><br><span class="line">    hwaddr base;</span><br><span class="line">    hwaddr size;</span><br><span class="line">&#125; nuclei_memmap[] = &#123;</span><br><span class="line">    [GD32VF103_EXMC_SWREG] = &#123; <span class="number">0xA0000000</span>,     <span class="number">0x1000</span> &#125;,</span><br><span class="line">    [GD32VF103_EXMC_SWREG] = &#123; <span class="number">0x60000000</span>,     <span class="number">0x10000000</span> &#125;,</span><br><span class="line">    [GD32VF103_USBFS]      = &#123; <span class="number">0x50000000</span>,     <span class="number">0x100000</span> &#125;,</span><br><span class="line">    [GD32VF103_CRC]        = &#123; <span class="number">0x40023000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_FMC]        = &#123; <span class="number">0x40022000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_RCU]        = &#123; <span class="number">0x40021000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_DMA1]       = &#123; <span class="number">0x40020400</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_DMA0]       = &#123; <span class="number">0x40020000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_UART4]     = &#123; <span class="number">0x40005000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_USART0]     = &#123; <span class="number">0x40013800</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_SRAM]       = &#123; <span class="number">0x20000000</span>,     <span class="number">0x18000</span> &#125;,</span><br><span class="line">    [GD32VF103_OB]         = &#123; <span class="number">0x1FFFF800</span>,     <span class="number">0x10</span> &#125;,</span><br><span class="line">    [GD32VF103_BL]         = &#123; <span class="number">0x1FFFB000</span>,     <span class="number">0x800</span> &#125;,</span><br><span class="line">    [GD32VF103_MAINFLASH]  = &#123; <span class="number">0x8000000</span>,     <span class="number">0x20000</span> &#125;,</span><br><span class="line">    [GD32VF103_MFOL]       = &#123;        <span class="number">0x0</span>,     <span class="number">0x20000</span> &#125;,</span><br><span class="line">    [GD32VF103_ECLIC]      = &#123; <span class="number">0xD2000000</span>,     <span class="number">0x10000</span> &#125;,</span><br><span class="line">    [GD32VF103_TIMER0]      = &#123; <span class="number">0x40012C00</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_SYSTIMER]      = &#123; <span class="number">0xD1000000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_AFIO]      = &#123; <span class="number">0x40010000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOA]      = &#123; <span class="number">0x40010800</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOB]      = &#123; <span class="number">0x40010C00</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOC]      = &#123; <span class="number">0x40011000</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOD]      = &#123; <span class="number">0x40011400</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">    [GD32VF103_GPIOE]      = &#123; <span class="number">0x40011800</span>,     <span class="number">0x400</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102160816431.png" alt="image-20221102160816431"></p>
<p>ILM 和DLM示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initialize SOC */</span></span><br><span class="line">  object_initialize_child(OBJECT(machine), <span class="string">&quot;soc&quot;</span>, &amp;s-&gt;soc, <span class="keyword">sizeof</span>(s-&gt;soc),</span><br><span class="line">                          TYPE_NUCLEI_SOC, &amp;error_abort, <span class="literal">NULL</span>);</span><br><span class="line">  object_property_set_bool(OBJECT(&amp;s-&gt;soc), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>,</span><br><span class="line">                          &amp;error_abort);</span><br><span class="line"></span><br><span class="line">  memory_region_init_ram(&amp;s-&gt;soc.ilm, <span class="literal">NULL</span>, <span class="string">&quot;riscv.nuclei.ram.ilm&quot;</span>,</span><br><span class="line">                         memmap[NUCLEI_ILM].size, &amp;error_fatal);</span><br><span class="line">  memory_region_add_subregion(system_memory, </span><br><span class="line">  memmap[NUCLEI_ILM].base, &amp;s-&gt;soc.ilm);</span><br><span class="line"></span><br><span class="line">  memory_region_init_ram(&amp;s-&gt;soc.dlm, <span class="literal">NULL</span>, <span class="string">&quot;riscv.nuclei.ram.dlm&quot;</span>,</span><br><span class="line">                         memmap[NUCLEI_DLM].size, &amp;error_fatal);</span><br></pre></td></tr></table></figure>

<p>hw/gpio/nrf51_gpio</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">nrf51_gpio_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    NRF51GPIOState *s = NRF51_GPIO(obj);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;mmio, obj, &amp;gpio_ops, s,</span><br><span class="line">            TYPE_NRF51_GPIO, NRF51_GPIO_SIZE);</span><br><span class="line">    sysbus_init_mmio(SYS_BUS_DEVICE(obj), &amp;s-&gt;mmio);</span><br><span class="line"></span><br><span class="line">    qdev_init_gpio_in(DEVICE(s), nrf51_gpio_set, NRF51_GPIO_PINS);</span><br><span class="line">    qdev_init_gpio_out(DEVICE(s), s-&gt;output, NRF51_GPIO_PINS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hw/riscv/nuclei_gd32vf103.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object_property_set_bool(OBJECT(&amp;s-&gt;gpioc), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br><span class="line"> object_property_set_bool(OBJECT(&amp;s-&gt;gpiod), <span class="literal">true</span>, <span class="string">&quot;realized&quot;</span>, &amp;err);</span><br><span class="line"> sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;gpioa), <span class="number">0</span>, memmap[GD32VF103_GPIOA].base);</span><br><span class="line"> sysbus_mmio_map(SYS_BUS_DEVICE(&amp;s-&gt;gpiob), <span class="number">0</span>, memmap[GD32VF103_GPIOB].base);</span><br></pre></td></tr></table></figure>

<h2 id="中断虚拟化"><a href="#中断虚拟化" class="headerlink" title="中断虚拟化"></a>中断虚拟化</h2><p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102161819367.png" alt="image-20221102161819367"></p>
<h2 id="外设虚拟化"><a href="#外设虚拟化" class="headerlink" title="外设虚拟化"></a>外设虚拟化</h2><p>uart，gpio等等。</p>
<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102165005081.png" alt="image-20221102165005081"></p>
<p><img src="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/image-20221102165105726.png" alt="image-20221102165105726"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/" data-id="cl9zgyneg0000wgmj3r2h4vuk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-rtos中断流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/" class="article-date">
  <time datetime="2022-10-28T01:43:49.000Z" itemprop="datePublished">2022-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/">rtos中断流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="RISCV中断和异常处理"><a href="#RISCV中断和异常处理" class="headerlink" title="RISCV中断和异常处理"></a>RISCV中断和异常处理</h2><p>RISCV架构下有三种特权级别，分别是Machine、Supervisor和User，简称M模式、S模式和U模式。M模式权限最高，在这个级别下的程序可以访问一切硬件和执行所有特权指令；S模式一般用于运行操作系统，可以设置MMU使用虚拟地址；U模式一般是普通应用程序使用，权限最低。</p>
<p>M模式使用物理地址进行访问，不经过MMU，但是有类似arm下cortex-m中的MPU功能；S模式可以通过设置MMU来使用虚拟地址访问内存，所以像Linux这类操作系统都运行在S模式下。那么有人要问了，为啥RISCV架构特权模式设计成这样，直接把M模式和S模式合二为一不行吗？这个得从RISCV架构诞生背景来看了，RISCV架构诞生于2010年左右，这时不管是x86还是arm架构都发展得算是比较成熟了，所以RISCV架构设计时就定位了从微控制器到大型超级计算机都可以使用这个架构。在微控制器上使用的RISCV架构一般只有M模式，或者使用M和U两种模式，类似于cortex-m架构的定位；而在带MMU的芯片上，RISCV架构一般都使用M、S和U三种模式，这样通过“拼积木”的方式就可以让RISCV架构适用于各种场景了。</p>
<p><strong>在arm下的应用程序通过“swi”指令可以将处理器从低特权级别切换到高特权级别，</strong>一般像Linux下的系统调用都是通过这种方式来使用的。类似的，<strong>在RISCV中，通过“ecall”指令可以从低特权切换到高特权</strong>，在U模式下执行就切换到S模式，在S模式下调用就切换到M模式。另外在RISCV中，默认产生中断和异常时，处理器自动切换到M模式处理，可以通过中断托管设置将一些中断和异常直接交给S模式处理。RISCV的架构设计就决定了必须要有程序运行在M模式下，来为S模式提供一些基础的服务，**RISCV为此定义了SBI(Supervisor Binary Interface)**接口规范，让运行在S模式下的操作系统在不同的RISCV处理器上都可以使用标准的SBI接口来使用相应的功能，这个其实就有点类似于x86下的BIOS概念了，详细的RISCV下中断和异常处理以及SBI规范在后续章节会讲解，这里只需要知道就可以。</p>
<h2 id="中断和异常处理"><a href="#中断和异常处理" class="headerlink" title="中断和异常处理"></a>中断和异常处理</h2><p>在RISCV架构设计中，有一系列的控制和状态寄存器( Control and Status Registers）简称CSR，在三种特权级别下都有其对应的CSR，比如m模式下的命名都为mxxxx，s模式下的都为sxxxx等等。这些寄存器的作用类似于arm架构中的那些cp15寄存器，用于设置异常向量表、设置页表基址、获取异常信息等等。这些寄存器大多数都需要通过“csr”这类指令来进行访问，也有一部分寄存器是采用mmio映射的，可以使用普通访存指令访问，比如timer相关的寄存器（后面会讲）。</p>
<table>
<thead>
<tr>
<th>CSR名称</th>
<th>访问属性</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>mvendorid</td>
<td>只读</td>
<td>厂商ID</td>
</tr>
<tr>
<td>marchId</td>
<td>只读</td>
<td>体系结构id</td>
</tr>
<tr>
<td>mimpid</td>
<td>只读</td>
<td>特点实现id</td>
</tr>
<tr>
<td>mhartid</td>
<td>只读</td>
<td>hart(硬件线程) id</td>
</tr>
<tr>
<td>misa</td>
<td>只读</td>
<td>指令集架构信息</td>
</tr>
<tr>
<td>mcycle/mycycleh</td>
<td>只读</td>
<td>时钟周期计数器</td>
</tr>
<tr>
<td>cycle/ycycleh</td>
<td>只读</td>
<td>时钟周期计数器</td>
</tr>
<tr>
<td>minstret</td>
<td>只读</td>
<td>退休指令计数器</td>
</tr>
<tr>
<td>mstatus</td>
<td>可读可写</td>
<td>状态控制</td>
</tr>
<tr>
<td>mie</td>
<td>可读可写</td>
<td>中断使能</td>
</tr>
<tr>
<td>mip</td>
<td>只读</td>
<td>当前中断pengding位</td>
</tr>
<tr>
<td>mtvec</td>
<td>可读可写</td>
<td>中断/异常矢量</td>
</tr>
<tr>
<td>mtval</td>
<td>可读可写</td>
<td>异常和中断的补充信息（如异常指令，非法地址）</td>
</tr>
<tr>
<td>mscratch</td>
<td>可读可写</td>
<td>提供一个上下文保存寄存器</td>
</tr>
<tr>
<td>mepc</td>
<td>可读可写</td>
<td>异常程序指针</td>
</tr>
<tr>
<td>mcause</td>
<td>只读</td>
<td>异常/中断原因</td>
</tr>
</tbody></table>
<p>上图中的寄存器被分为四类，其中和Trap相关的寄存器比较重要，用于中断和异常处理：</p>
<ul>
<li>信息类：主要用于获取当前芯片id和cpu核id等信息。</li>
<li>Trap设置：用于设置中断和异常相关寄存器。</li>
<li>Trap处理：用于处理中断和异常相关寄存器。</li>
<li>内存保护：作用类似于conterx-m中的mpu功能。</li>
</ul>
<h4 id="Machine-Information-Registers"><a href="#Machine-Information-Registers" class="headerlink" title="Machine Information Registers"></a>Machine Information Registers</h4><p>mvendorid、 marchid 和 mimpid 可以获取芯片制造商、架构和实现相关信息，最重要的还是 mhartid 这个寄存器，RISCV中每个cpu核都被称为一个hart，通过mhartid可以获取当前cpu核的id号。</p>
<h4 id="Machine-Trap-Setup"><a href="#Machine-Trap-Setup" class="headerlink" title="Machine Trap Setup"></a>Machine Trap Setup</h4><p>在RISCV中，中断（interrupt）和异常（exception）被统称为trap。在arm中我们知道中断和异常是通过中断向量表中不同入口调用不同的处理函数处理的，但是在riscv中，所有中断和异常一般都是使用的同一个处理入口。在x86和arm下都存在中断向量表的概念，用于定义不同异常和中断的处理入口，但是在riscv下，一般是不存在中断向量表这个概念的，只存在trap处理入口这个概念。为了表述上的方便，后续的章节都将trap处理入口称为中断入口，但是要明白这个入口不仅仅是处理中断的，同时也是处理异常的入口。中断入口在m模式和s模式下都有专门的寄存器需要设置，在本小节我们只看m模式下的相关寄存器，在使用中断和异常处理之前需要进行一些设置，下面就来看看这些寄存器如何设置。</p>
<h4 id="mtvec"><a href="#mtvec" class="headerlink" title="mtvec"></a>mtvec</h4><p>riscv支持向量中断和非向量中断两种编程模型， 非向量中断，也就是中断发生后，所有的入口只有一个，不固定偏移。</p>
<p> mtvec寄存器全名为Machine Trap-Vector Base-Address Register，用于设置中断入口地址，其寄存器格式如下</p>
<h1 id><a href="#" class="headerlink" title></a><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214110818111-230653853.png" alt="img"></h1><p> 可以看出mtvec需要中断入口地址是4字节对齐的，因为最低两个bit是用于设置中断模式的，其模式定义如下：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214111053532-1352962926.png" alt="img"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214110833752-872983711.png" alt="img"></p>
<ul>
<li>Direct模式：所有的中断和异常使用同一个中断入口地址，一般都会设置为这种模式。</li>
<li>Vectored模式：所有异常使用同一个入口地址，但是不同的中断使用不同的入口地址。</li>
</ul>
<h4 id="mstatus"><a href="#mstatus" class="headerlink" title="mstatus"></a>mstatus</h4><p>这个寄存器顾名思义是用来控制cpu核当前的一些状态信息的，比如全局中断使能等，寄存器的格式如下：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214110954103-633405226.png" alt="img"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214111004056-324285028.png" alt="img"></p>
<ul>
<li><p>红框内的位域用来控制全局中断的使能，SIE控制S模式下全局中断，MIE控制M模式下全局中断。这个有点像arm里cpsr中的F位，只是在RISCV架构下还分为S模式和M模式来控制，像但是不完全像。</p>
</li>
<li><p>绿框里的位域用来记录发生中断之前MIE和SIE的值。SPIE记录的是SIE的值，MPIE记录的是MIE的值。</p>
</li>
<li><p>蓝色框内位域用来记录当特权级别由低到高发生变化时（比如执行ecall指令），之前的特权级别。当变化后的特权级别是S模式时，SPP表示变化之前的特权级别是S模式还是U模式，所以只需要1位就可以表示；当变化后的特权级别是M模式时，MPP表示变化之前是S模式还是U模式还是M模式，由于有三种情况，所以需要使用2位来表示。</p>
</li>
<li><p>注意：当发生中断时，SIE和MIE被硬件自动设置为0，用来屏蔽中断，这个行为和大部分架构都一样，同时MPIE和SPIE被硬件自动设置为MIE和SIE的值，如果特权级别还发生改变的话，之前的特权级别是记录在SPP或者MPP中的。当从中断中返回时，SIE和MIE被自动设置为MPIE和SPIE的值，同时MPIE和SPIE被自动设置为1，特权级别恢复为MPP或者SPP记录的级别，然后MPP或者SPP被设置为U模式。</p>
</li>
</ul>
<h4 id="mie"><a href="#mie" class="headerlink" title="mie"></a>mie</h4><p>在RISCV下，将中断（interrupt）又细分为三种类型：定时中断(timer)、核间中断(soft)、中断控制器中断(external)。定时中断可以用于产生系统的tick，核间中断用于不同cpu核之间通信，中断控制器则负责所有外设中断。这个设计和arm下有点不一样，在arm多核下，架构中的定时器中断、核间中断和外设中断都是统一由中断控制器管理的，而在RISCV中定时器和核间中断是分离出来的，这两个中断被称为CLINT（Core Local Interrupt），而管理其他外设中断的中断控制器则被称为PLIC（Platform-Level Interrupt Controller）。每个核都有自己的定时器和产生核间中断的寄存器可以设置，这些寄存器的访问不同于其他的控制状态寄存器，采用的是MMIO映射方式访问，比如下图所示为SIFIVE FU540的CLINT寄存器表：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214114537637-1524564992.png" alt="img"></p>
<p>图中的msip用于产生m模式下的核间中断，mtime可以读取出当前计数器的值，mtimecmp用于设置比较值，当mtime的值增加到mtimecmp的值时就可以产生中断。这些寄存器的具体用法在后续的裸机程序编写章节会讲解，这里只需要简单了解即可。</p>
<p>上述讲解的三种中断类型在m模式和s模式下都有相应的中断使能位设置，这是通过mie寄存器实现的<strong>，mie寄存器的格式如下：</strong></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214114633507-942051388.png" alt="img"></p>
<ul>
<li>MSIE、MTIE、MEIE这三个位域分别控制m模式下核间中断、定时中断、中断控制器中断的使能状态。</li>
<li>SSIE、STIE、SEIE这三个位域分别控制s模式下核间中断、定时中断、中断控制器中断的使能状态。</li>
</ul>
<h4 id="medeleg-和-mideleg"><a href="#medeleg-和-mideleg" class="headerlink" title="medeleg 和 mideleg"></a>medeleg 和 mideleg</h4><p>RISCV下默认所有中断和异常都是在m模式下处理的，但是有些时候我们需要将中断和异常直接交给s模式处理，这就是RISCV中的中断托管机制。通过mideleg寄存器，可以将三种中断交给s模式处理，通过medeleg寄存器，可以将异常交给s模式处理。下面来具体看看这些寄存器格式。</p>
<p>当我们想把中断交给s模式处理时，我们可以设置mideleg寄存器，这个寄存器格式如下：</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214114753859-1265781757.png" alt="img"></p>
<ul>
<li>bit[1]用于控制是否将核间中断交给s模式处理。</li>
<li>bit[5]用于控制是否将定时中断交给s模式处理。</li>
<li>bit[9]用于控制是否将中断控制器管理的中断交给s模式处理。</li>
</ul>
<p>注意对于<strong>核间中断和定时中断而言，即使使能了mideleg中对应的bit位，当产生相应中断时，还是先进入m模式进行处理，然后可以通过设置mip寄存器(下一小节讲解)，在退出m模式中断时就可以进入s模式的中断处理函数中处理。</strong></p>
<p>当我们想把异常交给s模式处理时，我们可以设置medelrg寄存器，这个寄存器格式如下：</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115020818-510847302.png" alt="img"></p>
<p>可以看出来有很多异常是可以设置到s模式下处理的，但是实际使用时并不是所有异常都要交给s模式处理的，比如bit[9]代表的异常还是要交给m模式处理，因为像获取芯片id、cpu核id、设置timer等操作只能在m模式下进行，所以s模式通过SBI接口(后面会讲)使用“ecall”切换到m模式调用不同的服务，所以bit[9]代表的异常必须被m模式处理而不能交给s模式处理。</p>
<h4 id="Machine-Trap-Handling"><a href="#Machine-Trap-Handling" class="headerlink" title="Machine Trap Handling"></a>Machine Trap Handling</h4><p>当产生中断或者异常时，会有一些信息保存在相应的寄存器中，下面我们就一起来看看这些寄存器。</p>
<h4 id="mepc"><a href="#mepc" class="headerlink" title="mepc"></a>mepc</h4><p>在arm架构中，当发生中断或异常时，硬件自动将要返回的地址保存在lr寄存器中。类似的，在RISCV下产生中断或异常时，硬件自动将返回地址保存在mepc寄存器中，当在中断处理中返回时，硬件自动将mepc中的地址赋值给pc运行。</p>
<p>要注意的时，在RISCV架构中，当产生的时异常时，mepc中保存的是产生异常那条指令的地址，而不是其下一条指令地址，这么设计的原因是希望产生异常时，软件开发人员对相应异常做出处理，当处理完之后再次给一个运行之前产生异常指令的机会，比如缺页异常就是通过这种机制来运行的。当不需要再次运行产生异常那条指令时，需要在中断处理时手动将mepc的值加4，这样中断返回时就是运行产生异常那条指令的下一条指令。当产生的是中断时，mepc直接保存的就是被中断指令的下一条指令的地址，所以需要做修正。</p>
<h4 id="mcause和mtval"><a href="#mcause和mtval" class="headerlink" title="mcause和mtval"></a>mcause和mtval</h4><p>当产生中断和异常时，mcause寄存器中会记录当前产生的中断或者异常类型，而mtval则针对某些异常会记录一些辅助信息。我们来看看mcause寄存器的格式：</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115131193-1282204265.png" alt="img"> </p>
<p>寄存器的最高位用来表示产生的是中断还是异常，1表示中断0表示异常。剩下的位域表示中断或者异常的具体类型，如下所示：</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115157627-1953252108.png" alt="img"></p>
<p>可以看出来中断有6种类型，分别表示m和s模式下的定时、核间、中断控制器这三种中断，而异常的类型就比较多了。</p>
<h4 id="mip"><a href="#mip" class="headerlink" title="mip"></a>mip</h4><p>这个寄存器可以表明当前是否产生了某种中断，其格式如下所示。</p>
<p> <img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/665372-20211214115301918-476443465.png" alt="img"> </p>
<ul>
<li><p>MSIP表示m模式核间中断，此位只读，其状态反应的是CLINT中对应的核间中断设置寄存器最低位的状态，设置CLINT核间中断设置寄存器最低位为1则产生核间中断，置0则清除核间中断。</p>
</li>
<li><p>MTIP表示m模式定时中断，此位只读，其状态通过设置CLINT中对应的mtimecmp寄存器来清零。</p>
</li>
<li><p>MEIP表示m模式中断控制器中断，此位只读，其状态通过具体的中断控制器寄存器设置来清零。</p>
</li>
<li><p>SSIP表示s模式核间中断，此位在s模式只读(s模式下有sip寄存器，下面会讲)，在m模式下可读写，通过设置此位，可以进入s模式核间中断处理。</p>
</li>
<li><p>STIP表示s模式定时中断，此位在m模式下可读写，通过设置此位，可以进入s模式定时中断处理。</p>
</li>
<li><p>SEIP表示s模式中断控制器中断<strong>，此位在m模式下可读写，通过设置此位，可以进入s模式中断控制器中断处理</strong>。</p>
</li>
</ul>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><p>RISC-V定义了4种中断类型，大体上和ARM架构的中断类似，中断类型选取都是通过屏蔽寄存器来控制，下面所说的由xx寄存器控制就是指由xx寄存器来负责屏蔽某种中断类型</p>
<h3 id="外部中断External-Interrupt"><a href="#外部中断External-Interrupt" class="headerlink" title="外部中断External Interrupt"></a>外部中断External Interrupt</h3><p>来自核心外的中断，常见的GPIO、UART中断都属于这个中断</p>
<p>由CSR寄存器mie中的MEIE控制，等待标志反映在CSR寄存器mip中的MEIP域</p>
<h3 id="定时器（也就是计时器）中断Timer-Interrupt"><a href="#定时器（也就是计时器）中断Timer-Interrupt" class="headerlink" title="定时器（也就是计时器）中断Timer Interrupt"></a>定时器（也就是计时器）中断Timer Interrupt</h3><p>来自定时器的中断</p>
<p>由mie寄存器的MTIE域控制，等待标志反映在mip寄存器中的MTIP域</p>
<h3 id="软件中断Software-Interrupt"><a href="#软件中断Software-Interrupt" class="headerlink" title="软件中断Software Interrupt"></a>软件中断Software Interrupt</h3><p>来自软件自己触发的中断</p>
<p>由mie寄存器中的MSIE域控制，等待标志反映在mip寄存器的MSIP域</p>
<p>RISC-V定义了一个平台级别中断控制器PLIC（Platform Level Interrupt Controller），可用于多个外部中断源的优先级仲裁和派发</p>
<p>PLIC可以将多个外部中断源仲裁为一个bit的中断信号送入处理器核，处理器核接收到中断进入异常服务程序后可以通过读PLIC的相关寄存器查看中断源的编号和信息，在处理完响应中断服务程序后可以通过写PLIC的相关九年起和外部中断源寄存器来清除中断源</p>
<p>PLIC就相当于RISC-V上的弱化版NVIC</p>
<p>RISC-V规定系统平台至少有一个定时器，并应配由2个64位寄存器mtime（反映当前定时器的计数值）和mtimecmp（设置计时器比较值），当mtime中的计数值大于等于mtimecmp中设置的比较值时，计时器就会产生计时器中断，中断期间会一直拉高直到重写mtimecmp的值大于mtime中的值</p>
<p>特别地，两个定时器寄存器不归属于CSR寄存器，而是定义为存储器地址映射的系统寄存器，由配套SoC控制，这样就使得位于内核中的定时器变成了“一半外设”</p>
<p>这个定时器的时钟必须是为低速（意味着省电）的电源常开（意味着准确稳定）的时钟，它是一种实时计时器。</p>
<h2 id="ECLIC"><a href="#ECLIC" class="headerlink" title="ECLIC"></a>ECLIC</h2><p>eclic的设计是芯来科技设计的一种中断处理方式。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/o4YBAGB31wmAUvWWAABTpScNtJw692.png" alt="2dbc5852-9d0e-11eb-8b86-12bb97331649.png"></p>
<p>eclic目前也是众多芯来科技core采用的中断控制器，也包括<a target="_blank" rel="noopener" href="https://bbs.elecfans.com/group_1508">gd32</a>vf103系列的芯片。</p>
<p>3号中断是内核TIMER单元生成的软件中断。</p>
<p>7号中断是内核TIMER单元生成的计时器中断。</p>
<p>而从19~4095中断号都是外部中断，其中断的编号与中断的优先级其实没有关系。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/o4YBAGB31wmALc2vAAKME4-z1Es208.png" alt="2dcb96f0-9d0e-11eb-8b86-12bb97331649.png"></p>
<p>而对于ECLIC的寄存器布局，可见上图。</p>
<p>cliccfg是中断全局配置寄存器，可以结合clicintctl[i]配置</p>
<p>clicinfo也是全局寄存器中的数据，对于使用上来说，是只读的</p>
<p>mth中断的阈值级别寄存器</p>
<p>clicintip[i]是中断等待寄存器，也相当于pending寄存器</p>
<p>clicintie[i]为中断使能寄存器</p>
<p>clicintattr[i]为中断的属性，可以设置中断的上升沿触发或者下降沿触发，同时也可以设置中断从处理是向量中断还是非向量中断。</p>
<p>clicintctl[i] 设置中断优先级级别和优先级，需要配合cliccfg设置阈。</p>
<h3 id="关于jalmnxti"><a href="#关于jalmnxti" class="headerlink" title="关于jalmnxti"></a>关于jalmnxti</h3><p>这个也是eclic为了减少中断延时，加速中断咬尾的自定义指令。</p>
<p>该指令是配合eclic处理机制设计的，其指令功能比较多</p>
<p>开启中断使能，处理下一个中断</p>
<p>返回下一个中断入口地址</p>
<p>跳转至中断handler</p>
<p>中断处理后返回</p>
<p>由于<a target="_blank" rel="noopener" href="http://www.elecfans.com/tags/csr/">csr</a>rw ra， CSR_JALMNXTI， ra一条指令可以达到JAL（Jump and Link）的效果，同时硬件上更新Link寄存器作为该指令的PC作为函数调用的返回值，因此从中断服务程序返回后，又会重新回到csrrw ra， CSR_JALMNXTI， ra指令再次执行，可以重新判断是否有中断pending，如果有则跳转到中断处理函数，从而实现中断的咬尾处理，如果没有中断等待，则jalmnxti实际上并不会做任何事情。</p>
<h2 id="在rt-thread中的一个中断流程"><a href="#在rt-thread中的一个中断流程" class="headerlink" title="在rt-thread中的一个中断流程"></a>在rt-thread中的一个中断流程</h2><p>在startup_cm32m4xxr.S中定义eclic_msip_hander中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.section .vtable</span><br><span class="line"></span><br><span class="line">    .weak  eclic_msip_handler   <span class="comment">// 用户级软件中断</span></span><br><span class="line">    .weak  eclic_mtip_handler </span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* CM32M4xxR interrupt handlers */</span></span><br><span class="line">    .weak  WWDG_IRQHandler</span><br><span class="line">    .weak  PVD_IRQHandler</span><br><span class="line">    .weak  TAMPER_IRQHandler</span><br><span class="line">    .weak  RTC_IRQHandler</span><br><span class="line">    .weak  FLASH_IRQHandler</span><br><span class="line">    .weak  RCC_IRQHandler</span><br><span class="line">    .weak  EXTI0_IRQHandle</span><br></pre></td></tr></table></figure>

<p>中断入口函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set ECLIC non-vector entry to be controlled</span></span><br><span class="line"><span class="comment"> * by mtvt2 CSR register.</span></span><br><span class="line"><span class="comment"> * Intialize ECLIC non-vector interrupt</span></span><br><span class="line"><span class="comment"> * base address mtvt2 to irq_entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">la t0, irq_entry</span><br><span class="line">csrw CSR_MTVT2, t0</span><br><span class="line">csrs CSR_MTVT2, <span class="number">0x1</span></span><br></pre></td></tr></table></figure>

<p>在interrupt_gcc.S中完成了中断入口函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">.global irq_entry</span><br><span class="line"><span class="comment">/* This label will be set to MTVT2 register */</span></span><br><span class="line">irq_entry:</span><br><span class="line">    <span class="comment">/* Save the caller saving registers (context) */</span></span><br><span class="line">    SAVE_CONTEXT</span><br><span class="line">    <span class="comment">/* Save the necessary CSR registers */</span></span><br><span class="line">    SAVE_CSR_CONTEXT</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This special CSR read/write operation, which is actually</span></span><br><span class="line"><span class="comment">     * claim the CLIC to find its pending highest ID, if the ID</span></span><br><span class="line"><span class="comment">     * is not 0, then automatically enable the mstatus.MIE, and</span></span><br><span class="line"><span class="comment">     * jump to its vector-entry-label, and update the link register</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">       <span class="comment">/* 跳转到具体中断函数的语句，功能如上所述*/</span></span><br><span class="line">    csrrw ra, CSR_JALMNXTI, ra</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Critical section with interrupts disabled */</span></span><br><span class="line">    DISABLE_MIE</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore the necessary CSR registers */</span></span><br><span class="line">    RESTORE_CSR_CONTEXT</span><br><span class="line">    <span class="comment">/* Restore the caller saving registers (context) */</span></span><br><span class="line">    RESTORE_CONTEXT</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return to regular code */</span></span><br><span class="line">    mret</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Default Handler for Exceptions / Interrupts */</span></span><br></pre></td></tr></table></figure>

<p>上下文保存的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rt_hw_stack_frame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> epc;        <span class="comment">/*!&lt; epc - epc    - program counter                     */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> ra;         <span class="comment">/*!&lt; x1  - ra     - return address for jumps            */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t0;         <span class="comment">/*!&lt; x5  - t0     - temporary register 0                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t1;         <span class="comment">/*!&lt; x6  - t1     - temporary register 1                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t2;         <span class="comment">/*!&lt; x7  - t2     - temporary register 2                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s0_fp;      <span class="comment">/*!&lt; x8  - s0/fp  - saved register 0 or frame pointer   */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s1;         <span class="comment">/*!&lt; x9  - s1     - saved register 1                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a0;         <span class="comment">/*!&lt; x10 - a0     - return value or function argument 0 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a1;         <span class="comment">/*!&lt; x11 - a1     - return value or function argument 1 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a2;         <span class="comment">/*!&lt; x12 - a2     - function argument 2                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a3;         <span class="comment">/*!&lt; x13 - a3     - function argument 3                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a4;         <span class="comment">/*!&lt; x14 - a4     - function argument 4                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a5;         <span class="comment">/*!&lt; x15 - a5     - function argument 5                 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_32e</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a6;         <span class="comment">/*!&lt; x16 - a6     - function argument 6                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> a7;         <span class="comment">/*!&lt; x17 - s7     - function argument 7                 */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s2;         <span class="comment">/*!&lt; x18 - s2     - saved register 2                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s3;         <span class="comment">/*!&lt; x19 - s3     - saved register 3                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s4;         <span class="comment">/*!&lt; x20 - s4     - saved register 4                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s5;         <span class="comment">/*!&lt; x21 - s5     - saved register 5                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s6;         <span class="comment">/*!&lt; x22 - s6     - saved register 6                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s7;         <span class="comment">/*!&lt; x23 - s7     - saved register 7                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s8;         <span class="comment">/*!&lt; x24 - s8     - saved register 8                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s9;         <span class="comment">/*!&lt; x25 - s9     - saved register 9                    */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s10;        <span class="comment">/*!&lt; x26 - s10    - saved register 10                   */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> s11;        <span class="comment">/*!&lt; x27 - s11    - saved register 11                   */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t3;         <span class="comment">/*!&lt; x28 - t3     - temporary register 3                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t4;         <span class="comment">/*!&lt; x29 - t4     - temporary register 4                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t5;         <span class="comment">/*!&lt; x30 - t5     - temporary register 5                */</span></span><br><span class="line">    <span class="type">rt_ubase_t</span> t6;         <span class="comment">/*!&lt; x31 - t6     - temporary register 6                */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">rt_ubase_t</span> mstatus;    <span class="comment">/*!&lt;              - machine status register             */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当我们新建一个线程，初始化线程时，会为其开辟一个线程栈（程序中通常设置一个数组），即对上述结构体做初始化，在rt-thread中的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">rt_err_t</span> _rt_thread_init(<span class="keyword">struct</span> rt_thread *thread,</span><br><span class="line">                                <span class="type">const</span> <span class="type">char</span>       *name,</span><br><span class="line">                                <span class="type">void</span> (*entry)(<span class="type">void</span> *parameter),</span><br><span class="line">                                <span class="type">void</span>             *parameter,</span><br><span class="line">                                <span class="type">void</span>             *stack_start,</span><br><span class="line">                                <span class="type">rt_uint32_t</span>       stack_size,</span><br><span class="line">                                <span class="type">rt_uint8_t</span>        priority,</span><br><span class="line">                                <span class="type">rt_uint32_t</span>       tick)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init thread list */</span></span><br><span class="line">    rt_list_init(&amp;(thread-&gt;tlist));</span><br><span class="line"></span><br><span class="line">    thread-&gt;entry = (<span class="type">void</span> *)entry;</span><br><span class="line">    thread-&gt;parameter = parameter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* stack init */</span></span><br><span class="line">    thread-&gt;stack_addr = stack_start;</span><br><span class="line">    thread-&gt;stack_size = stack_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init thread stack */</span></span><br><span class="line">    rt_memset(thread-&gt;stack_addr, <span class="string">&#x27;#&#x27;</span>, thread-&gt;stack_size);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ARCH_CPU_STACK_GROWS_UPWARD</span></span><br><span class="line">    thread-&gt;sp = (<span class="type">void</span> *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,</span><br><span class="line">                                          (<span class="type">void</span> *)((<span class="type">char</span> *)thread-&gt;stack_addr),</span><br><span class="line">                                          (<span class="type">void</span> *)rt_thread_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    thread-&gt;sp = (<span class="type">void</span> *)rt_hw_stack_init(thread-&gt;entry, thread-&gt;parameter,</span><br><span class="line">                                          (<span class="type">rt_uint8_t</span> *)((<span class="type">char</span> *)thread-&gt;stack_addr + thread-&gt;stack_size - <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>)),</span><br><span class="line">                                          (<span class="type">void</span> *)rt_thread_exit);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	............</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">rt_uint8_t</span> *<span class="title function_">rt_hw_stack_init</span><span class="params">(<span class="type">void</span>       *tentry,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *parameter,</span></span><br><span class="line"><span class="params">                             <span class="type">rt_uint8_t</span> *stack_addr,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span>       *texit)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rt_hw_stack_frame</span> *<span class="title">frame</span>;</span></span><br><span class="line">    <span class="type">rt_uint8_t</span>         *stk;</span><br><span class="line">    <span class="type">int</span>                i;</span><br><span class="line"></span><br><span class="line">    stk  = stack_addr + <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>);</span><br><span class="line">    stk  = (<span class="type">rt_uint8_t</span> *)RT_ALIGN_DOWN((<span class="type">rt_ubase_t</span>)stk, REGBYTES);</span><br><span class="line">    stk -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_hw_stack_frame);</span><br><span class="line"></span><br><span class="line">    frame = (<span class="keyword">struct</span> rt_hw_stack_frame *)stk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(<span class="keyword">struct</span> rt_hw_stack_frame) / <span class="keyword">sizeof</span>(<span class="type">rt_ubase_t</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ((<span class="type">rt_ubase_t</span> *)frame)[i] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame-&gt;ra      = (<span class="type">rt_ubase_t</span>)texit;</span><br><span class="line">    frame-&gt;a0      = (<span class="type">rt_ubase_t</span>)parameter;</span><br><span class="line">    frame-&gt;epc     = (<span class="type">rt_ubase_t</span>)tentry;</span><br><span class="line"></span><br><span class="line">    frame-&gt;mstatus = RT_INITIAL_MSTATUS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从堆栈初始化程序*rt_hw_stack_init中可以看出，其先将堆栈顶部地址对齐，然后向下偏移一个rt_hw_stack_frame结构体的大小，用于存储图1中需要存储的寄存器，并对该部分空间进行了初始化。其中把线程的入口地址给了mepc，线程输入参数给a0，mstatus初始值（MPP、MPIE、FS、MIE），即强制机器模式，使能浮点，MPIE为1，MIE为0。如果不带硬件浮点，可将该值设置为0x1880。另外设置ra为线程的返回地址，一般情况下一个线程我们希望一直运行的，当需要返回时说明该线程不再需要运行，所以返回地址一般是一段将该线程从线程列表中删除并切换至下一个线程的一段程序，即上面中调用的函数_rt_thread_exit。</p>
<p><strong>rt-thread的详细的启动流程。</strong>rt-thread定义一个rt_thread类型的全局指针rt_current_thread，用于实时获取当前运行的线程。从图9可知，硬件启动后进rtthread_startup，其开始进行了必要的初始化，如系统滴答定时器、堆、串口、调度器、定时器、main线程、空闲idle线程等等，最后执行了rt_system_scheduler_start后转交调度器执行。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/image-20221028110054550.png" alt="image-20221028110054550"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/image-20221028110132550.png" alt="image-20221028110132550"></p>
<p>由图2可知，其会查找优先级较高的就绪组优先级，并根据该优先级查找就绪链表，获取优先级较高的任务并得到控制块to_thread，然后调用rt_hw_context_switch_to切换至该任务。其是一段汇编实现的代码，传入的参数为该任务的sp指针。由前文可知，我们可以根据to_thread-&gt;sp得到该任务的堆栈位置，该堆栈的顶部空间存储了执行该任务时cpu寄存器的值，由此也可推测该部分汇编代码主要完成的就是从sp处恢复cpu寄存器值，并转而执行该任务。其代码如下图3所示，详见注释。</p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/v2-2a3cd8c82045fccaf5b278e5d1c3a759_1440w.webp" alt="img"></p>
<p><img src="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/v2-3672e11c8f2cc78763d2f598bc1c0ac9_1440w.webp" alt="img"></p>
<p>由上注释分析可知，rt_hw_context_switch_to通过传入的sp，恢复cpu寄存器，其中mepc寄存器任务初始化时设置为任务的入口地址，ra寄存器设置为返回地址，其指向公用函数_rt_thread_exit。当mret返回后，pc更新为mepc值，即转向执行任务函数，若其不是一个持续执行的[while(1)]函数，那么其返回至_rt_thread_exit，删除该任务，并切换至其他任务。由此也可理解图2中，最后一句注释“never come back”的含义了，一旦开始执行任务，pc值被改变，再不会回到调用的地方。</p>
<p>rt_schedule()函数切换上下文的过程，则是挂起一个中断，然后在中断服务函数中实现上下文切换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rt_hw_context_switch</span><span class="params">(<span class="type">rt_ubase_t</span> from, <span class="type">rt_ubase_t</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rt_thread_switch_interrupt_flag == <span class="number">0</span>)</span><br><span class="line">        rt_interrupt_from_thread = from;</span><br><span class="line"></span><br><span class="line">    rt_interrupt_to_thread = to;</span><br><span class="line">    rt_thread_switch_interrupt_flag = <span class="number">1</span>;</span><br><span class="line">    RT_YIELD();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Scheduler utilities. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RT_YIELD()                                                              \</span></span><br><span class="line"><span class="meta">&#123;                                                                               \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Set a software interrupt(SWI) request to request a context switch. */</span>    \</span></span><br><span class="line"><span class="meta">    SysTimer_SetSWIRQ();                                                        \</span></span><br><span class="line"><span class="meta">    <span class="comment">/* Barriers are normally not required but do ensure the code is completely  \</span></span></span><br><span class="line"><span class="comment"><span class="meta">    within the specified behaviour for the architecture. */</span>                     \</span></span><br><span class="line"><span class="meta">    __RWMB();                                                                   \</span></span><br><span class="line"><span class="meta">    __FENCE_I();                                                                \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line">__STATIC_FORCEINLINE <span class="type">void</span> <span class="title function_">SysTimer_SetSWIRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hartid = __RV_CSR_READ(CSR_MHARTID);</span><br><span class="line">    <span class="keyword">if</span> (hartid == <span class="number">0</span>) &#123;</span><br><span class="line">        SysTimer-&gt;MSIP |= SysTimer_MSIP_MSIP_Msk;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint8_t</span> *addr = (<span class="type">uint8_t</span> *)(SysTimer_CLINT_MSIP_BASE(hartid));</span><br><span class="line">        __SW(addr, SysTimer_MSIP_MSIP_Msk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中断服务函数实体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">.global eclic_msip_handler</span><br><span class="line">eclic_msip_handler:</span><br><span class="line">    addi sp, sp, -RT_CONTEXT_SIZE</span><br><span class="line">    STORE x1,  <span class="number">1</span>  * REGBYTES(sp)    <span class="comment">/* RA */</span></span><br><span class="line">    STORE x5,  <span class="number">2</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x6,  <span class="number">3</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x7,  <span class="number">4</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x8,  <span class="number">5</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x9,  <span class="number">6</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x10, <span class="number">7</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x11, <span class="number">8</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x12, <span class="number">9</span>  * REGBYTES(sp)</span><br><span class="line">    STORE x13, <span class="number">10</span> * REGBYTES(sp)</span><br><span class="line">    STORE x14, <span class="number">11</span> * REGBYTES(sp)</span><br><span class="line">    STORE x15, <span class="number">12</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_32e</span></span><br><span class="line">    STORE x16, <span class="number">13</span> * REGBYTES(sp)</span><br><span class="line">    STORE x17, <span class="number">14</span> * REGBYTES(sp)</span><br><span class="line">    STORE x18, <span class="number">15</span> * REGBYTES(sp)</span><br><span class="line">    STORE x19, <span class="number">16</span> * REGBYTES(sp)</span><br><span class="line">    STORE x20, <span class="number">17</span> * REGBYTES(sp)</span><br><span class="line">    STORE x21, <span class="number">18</span> * REGBYTES(sp)</span><br><span class="line">    STORE x22, <span class="number">19</span> * REGBYTES(sp)</span><br><span class="line">    STORE x23, <span class="number">20</span> * REGBYTES(sp)</span><br><span class="line">    STORE x24, <span class="number">21</span> * REGBYTES(sp)</span><br><span class="line">    STORE x25, <span class="number">22</span> * REGBYTES(sp)</span><br><span class="line">    STORE x26, <span class="number">23</span> * REGBYTES(sp)</span><br><span class="line">    STORE x27, <span class="number">24</span> * REGBYTES(sp)</span><br><span class="line">    STORE x28, <span class="number">25</span> * REGBYTES(sp)</span><br><span class="line">    STORE x29, <span class="number">26</span> * REGBYTES(sp)</span><br><span class="line">    STORE x30, <span class="number">27</span> * REGBYTES(sp)</span><br><span class="line">    STORE x31, <span class="number">28</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* Push mstatus to stack */</span></span><br><span class="line">    csrr t0, CSR_MSTATUS</span><br><span class="line">    STORE t0,  (RT_SAVED_REGNUM - <span class="number">1</span>)  * REGBYTES(sp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Push additional registers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store sp to task stack */</span></span><br><span class="line">    LOAD t0, rt_interrupt_from_thread</span><br><span class="line">    STORE sp, <span class="number">0</span>(t0)</span><br><span class="line"></span><br><span class="line">    csrr t0, CSR_MEPC</span><br><span class="line">    STORE t0, <span class="number">0</span>(sp)</span><br><span class="line"></span><br><span class="line">    jal rt_hw_taskswitch</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Switch task context */</span></span><br><span class="line">    LOAD t0, rt_interrupt_to_thread</span><br><span class="line">    LOAD sp, <span class="number">0x0</span>(t0)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop PC from stack and set MEPC */</span></span><br><span class="line">    LOAD t0,  <span class="number">0</span>  * REGBYTES(sp)</span><br><span class="line">    csrw CSR_MEPC, t0</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop additional registers */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pop mstatus from stack and set it */</span></span><br><span class="line">    LOAD t0,  (RT_SAVED_REGNUM - <span class="number">1</span>)  * REGBYTES(sp)</span><br><span class="line">    csrw CSR_MSTATUS, t0</span><br><span class="line">    <span class="comment">/* Interrupt still disable here */</span></span><br><span class="line">    <span class="comment">/* Restore Registers from Stack */</span></span><br><span class="line">    LOAD x1,  <span class="number">1</span>  * REGBYTES(sp)    <span class="comment">/* RA */</span></span><br><span class="line">    LOAD x5,  <span class="number">2</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x6,  <span class="number">3</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x7,  <span class="number">4</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x8,  <span class="number">5</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x9,  <span class="number">6</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x10, <span class="number">7</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x11, <span class="number">8</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x12, <span class="number">9</span>  * REGBYTES(sp)</span><br><span class="line">    LOAD x13, <span class="number">10</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x14, <span class="number">11</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x15, <span class="number">12</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __riscv_32e</span></span><br><span class="line">    LOAD x16, <span class="number">13</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x17, <span class="number">14</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x18, <span class="number">15</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x19, <span class="number">16</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x20, <span class="number">17</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x21, <span class="number">18</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x22, <span class="number">19</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x23, <span class="number">20</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x24, <span class="number">21</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x25, <span class="number">22</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x26, <span class="number">23</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x27, <span class="number">24</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x28, <span class="number">25</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x29, <span class="number">26</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x30, <span class="number">27</span> * REGBYTES(sp)</span><br><span class="line">    LOAD x31, <span class="number">28</span> * REGBYTES(sp)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    addi sp, sp, RT_CONTEXT_SIZE</span><br><span class="line">    mret</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/" data-id="cl9rwxhuj0000rgmjfkqo7gpe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构位图" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/" class="article-date">
  <time datetime="2022-10-24T01:57:27.000Z" itemprop="datePublished">2022-10-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/">数据结构位图</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>一个字节可以用来存储8个连续的整数，一个整数4个字节的话，当要存储40亿个整数时，按之前数组存储的方式需要大概16G的内存，显然不合理。使用位图的话，只需要500M的内存。</p>
<p>位图初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitmap(<span class="type">int</span> size)&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">	<span class="built_in">memset</span>(arr,<span class="number">0</span>,(size&gt;&gt;<span class="number">32</span>+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）"><a href="#1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）" class="headerlink" title="1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）"></a>1、计算N属于那个单元，然后计算在单元的某个位置（查找x的位置）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index = N &gt;&gt;<span class="number">5</span>;  <span class="comment">// 一个int类型的数据可以存储32个连续的整数，右移5位相当于除以32</span></span><br><span class="line">num = N %<span class="number">32</span>;    <span class="comment">// num &amp; 31</span></span><br></pre></td></tr></table></figure>

<h3 id="2、将位置x置位1"><a href="#2、将位置x置位1" class="headerlink" title="2、将位置x置位1"></a>2、将位置x置位1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据在内存中按小端方式存放</span></span><br><span class="line">arr[index] |= (<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-num))  <span class="comment">// &amp;31 相当于 %32 因为 31的2进制数为0x1111</span></span><br></pre></td></tr></table></figure>

<h3 id="3、将x位置上的数字清空"><a href="#3、将x位置上的数字清空" class="headerlink" title="3、将x位置上的数字清空"></a>3、将x位置上的数字清空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[index] &amp;=~(<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-num))</span><br></pre></td></tr></table></figure>

<h3 id="4、判断位图中是否包含这个数"><a href="#4、判断位图中是否包含这个数" class="headerlink" title="4、判断位图中是否包含这个数"></a>4、判断位图中是否包含这个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[index] &amp; (<span class="number">1</span>&lt;&lt;(<span class="number">31</span>-num)) !=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="rt-thread中的位图优先级"><a href="#rt-thread中的位图优先级" class="headerlink" title="rt-thread中的位图优先级"></a>rt-thread中的位图优先级</h2><p><img src="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/image-20221107133426982.png" alt="image-20221107133426982"></p>
<p><img src="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/image-20221107133505042.png" alt="image-20221107133505042"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">INT8U  <span class="type">const</span>  OSUnMapTbl[<span class="number">256</span>] = &#123; </span><br><span class="line">  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x00 to 0x0F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x10 to 0x1F                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x20 to 0x2F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x30 to 0x3F                             */</span></span><br><span class="line">  <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x40 to 0x4F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x50 to 0x5F                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x60 to 0x6F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x70 to 0x7F                             */</span></span><br><span class="line">  <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x80 to 0x8F                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0x90 to 0x9F                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xA0 to 0xAF                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xB0 to 0xBF                             */</span></span><br><span class="line">  <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xC0 to 0xCF                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xD0 to 0xDF                             */</span></span><br><span class="line">  <span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,       <span class="comment">/* 0xE0 to 0xEF                             */</span></span><br><span class="line">  <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>        <span class="comment">/* 0xF0 to 0xFF                             */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __rt_ffs(<span class="type">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp; <span class="number">0xff</span>)</span><br><span class="line">        <span class="keyword">return</span> __lowest_bit_bitmap[value &amp; <span class="number">0xff</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp; <span class="number">0xff00</span>)</span><br><span class="line">        <span class="keyword">return</span> __lowest_bit_bitmap[(value &amp; <span class="number">0xff00</span>) &gt;&gt; <span class="number">8</span>] + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &amp; <span class="number">0xff0000</span>)</span><br><span class="line">        <span class="keyword">return</span> __lowest_bit_bitmap[(value &amp; <span class="number">0xff0000</span>) &gt;&gt; <span class="number">16</span>] + <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> __lowest_bit_bitmap[(value &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>] + <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/" data-id="cl9m644td00012omje6i22zzx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-riscv汇编语言编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/21/riscv%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2022-10-21T05:40:27.000Z" itemprop="datePublished">2022-10-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/21/riscv%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/">riscv汇编语言编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><strong>一个完整的risc-v汇编程序是由多条语句(statment)构成的</strong></p>
</li>
<li><p><strong>一条典型的RISC-V汇编语句是由3部分组成的：</strong></p>
<p>[label:] [operation] [comment]</p>
</li>
<li><p><strong>label(标号)：GNU汇编中，任何以冒号结尾的标识符都被认为是一个标号</strong></p>
</li>
<li><p><strong>operation 可以有以下多种类型：</strong></p>
<p><strong>instruction(指令)</strong>: 直接应对二进制机器指令的字符串</p>
<p>**pseudo-instruction(伪指令)**：为了提高编写代码的效率，可以用一条伪指令指示汇编器产生多条实际的指令(instructions)</p>
<p>**directive(指示/伪操作)**：通过类似指令的形式（”.”开头），通知汇编器如何控制代码的产生，不对应具体的指令。</p>
<p>**macro:**采用.marco/.endm 自定义宏</p>
</li>
</ul>
<h3 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h3><p>​    32个通用寄存器，x0-x31</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/21/riscv%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" data-id="cl9m644ta00002omj6j6h78w8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-优先级任务调度实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/20/%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2022-10-20T08:12:07.000Z" itemprop="datePublished">2022-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/20/%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/">优先级任务调度实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="任务控制块的结构体以及链表结构"><a href="#任务控制块的结构体以及链表结构" class="headerlink" title="任务控制块的结构体以及链表结构"></a>任务控制块的结构体以及链表结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcb_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span> *<span class="title">head</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span> *<span class="title">tail</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span>&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span> *<span class="title">prev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcb</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">void</span>            *<span class="built_in">stack</span>;  <span class="comment">// 栈的开始地址</span></span><br><span class="line">	<span class="type">uint32_t</span>        stack_size; <span class="comment">//栈的大小</span></span><br><span class="line">	<span class="type">entry_t</span>          entry;  <span class="comment">// 绑定函数</span></span><br><span class="line">	<span class="type">uint32_t</span>         prio;   <span class="comment">//优先级</span></span><br><span class="line">	<span class="type">void</span>            *arg;    <span class="comment">// 函数参数</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">thread_state</span> <span class="title">state</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span>         time;</span><br><span class="line">	<span class="type">uint32_t</span>         timeout;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">context</span>   <span class="title">context</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_list</span> *<span class="title">list_sched</span>;</span>  <span class="comment">// 调度队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_list</span> *<span class="title">list_wait</span>;</span>   <span class="comment">// 等待队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span>  <span class="title">node_sched</span>;</span>  <span class="comment">// 调度队列的结点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb_node</span>  <span class="title">node_wait</span>;</span>	  <span class="comment">// 等待队列的结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相关的一些接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">thread_t</span> <span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> *(*entry)(<span class="type">void</span> *),<span class="type">void</span> *arg,<span class="type">uint32_t</span> stack_size)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">	<span class="type">uint8_t</span> *stack_base;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果给的stack_size值为0,贼赋值为默认值1024</span></span><br><span class="line">	stack_size = stack_size?stack_size:<span class="number">1024</span>;</span><br><span class="line">	tcb = (<span class="keyword">struct</span> tcb *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcb)+stack_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(tcb != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			stack_base = (<span class="type">uint8_t</span> *)(tcb + <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">memset</span>(tcb, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> tcb));</span><br><span class="line">			<span class="built_in">memset</span>(stack_base, <span class="number">0xCC</span>, stack_size);</span><br><span class="line">			tcb-&gt;prio  = THREAD_PRIORITY_NORMAL;</span><br><span class="line">			tcb-&gt;stack_size =  stack_size;</span><br><span class="line">			tcb-&gt;arg = arg;</span><br><span class="line">			tcb-&gt;context.ra = (<span class="type">uint32_t</span>)entry;</span><br><span class="line">			tcb-&gt;context.sp = (<span class="type">uint32_t</span>)(tcb-&gt;<span class="built_in">stack</span>)+tcb-&gt;stack_size;</span><br><span class="line">			tcb-&gt;<span class="built_in">stack</span> = (stack_base);</span><br><span class="line">			tcb-&gt;entry = entry;</span><br><span class="line">			tcb-&gt;node_wait.tcb = tcb;</span><br><span class="line">			tcb-&gt;node_sched.tcb = tcb;</span><br><span class="line">			<span class="comment">//cpu_enter_critical();</span></span><br><span class="line">			sched_tcb_ready(tcb);  <span class="comment">// 插入到就绪队列</span></span><br><span class="line">			<span class="comment">//cpu_leave_critical();</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">thread_t</span>)tcb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_yield</span><span class="params">()</span>&#123;</span><br><span class="line">	sched_switch_yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thread_exit</span><span class="params">()</span>&#123;</span><br><span class="line">	sched_tcb_now= sched_tcb_next;</span><br><span class="line">	sched_tcb_remove(sched_tcb_now);</span><br><span class="line">	list_append(&amp;m_list_dead, &amp;sched_tcb_now-&gt;node_wait);</span><br><span class="line">	sched_switch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务调度的一些相关的数据结构和方法"><a href="#任务调度的一些相关的数据结构和方法" class="headerlink" title="任务调度的一些相关的数据结构和方法"></a>任务调度的一些相关的数据结构和方法</h2><p>当前执行的任务，下个要执行的任务，就绪任务队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcb</span>             *<span class="title">sched_tcb_now</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcb</span>             *<span class="title">sched_tcb_next</span>;</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcb_list</span>  <span class="title">m_list_ready</span>[<span class="title">THREAD_PRIORITY_HIGHEST</span> + 1];</span></span><br></pre></td></tr></table></figure>

<p>用于上下文切换的接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切换当前任务到下一个, tcb_context：保存主任务的上下文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_switch</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">	tcb = m_list_ready[m_prio_highest].head-&gt;tcb;</span><br><span class="line">	list_remove(tcb-&gt;list_sched, &amp;tcb-&gt;node_sched);</span><br><span class="line">	<span class="keyword">if</span>(tcb-&gt;list_sched-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_prio_bitmap &amp;= ~(<span class="number">1</span> &lt;&lt; tcb-&gt;prio);</span><br><span class="line">		m_prio_highest = find_highest_priority(m_prio_highest);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tcb-&gt;list_sched = <span class="literal">NULL</span>;</span><br><span class="line">	sched_tcb_next = tcb;</span><br><span class="line">	swtch(&amp;sched_tcb_now-&gt;context,&amp;sched_tcb_next-&gt;context);</span><br><span class="line">	<span class="comment">//cpu_contex_switch();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换当前任务到下一个, tcb_context：保存主任务的上下文</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sched_switch_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	sched_tcb_now = sched_tcb_next;</span><br><span class="line">	sched_tcb_ready(sched_tcb_now);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcb</span> *<span class="title">tcb</span>;</span></span><br><span class="line">	tcb = m_list_ready[m_prio_highest].head-&gt;tcb; <span class="comment">//找到当前最高优先级，那个链表中的第一个结点就是下一个结点</span></span><br><span class="line">	list_remove(tcb-&gt;list_sched, &amp;tcb-&gt;node_sched);  <span class="comment">// 将这个结点从就绪队列移除</span></span><br><span class="line">	<span class="keyword">if</span>(tcb-&gt;list_sched-&gt;head == <span class="literal">NULL</span>)  <span class="comment">// 如果是最后一个结点，则重新寻找最高优先级</span></span><br><span class="line">	&#123;</span><br><span class="line">		m_prio_bitmap &amp;= ~(<span class="number">1</span> &lt;&lt; tcb-&gt;prio);</span><br><span class="line">		m_prio_highest = find_highest_priority(m_prio_highest); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	tcb-&gt;list_sched = <span class="literal">NULL</span>;</span><br><span class="line">	sched_tcb_next = tcb;</span><br><span class="line">	swtch(&amp;sched_tcb_now-&gt;context,&amp;sched_tcb_next-&gt;context); <span class="comment">// 将当前环境切换到这个任务</span></span><br><span class="line">	<span class="comment">//cpu_contex_switch();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>实际使用，最好有一个空闲任务用来回收所有资源，并设置优先级，一直运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空闲线程，只需调用kernel_idle即可</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idle</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	kernel_idle();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于初始化应用程序的线程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//在这里完成外设和驱动初始化</span></span><br><span class="line">	<span class="comment">//并创建更多线程实现不同的功能</span></span><br><span class="line">	<span class="comment">//thread_create(...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序入口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言程序入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> heap[HEAP_SIZE]; <span class="comment">/* 定义堆内存 */</span></span><br><span class="line">	kernel_init(heap, <span class="keyword">sizeof</span>(heap)); <span class="comment">/* 系统初始化 */</span></span><br><span class="line">	thread_create(idle, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 创建idle线程 */</span></span><br><span class="line">	thread_create(init, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 创建init线程 */</span></span><br><span class="line">	kernel_start(); <span class="comment">/* 启动系统 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/20/%E4%BC%98%E5%85%88%E7%BA%A7%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0/" data-id="cl9gtg2yp00000wmj3auo01q3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于riscv使用汇编实现简单的任务调度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/18/%E5%9F%BA%E4%BA%8Eriscv%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" class="article-date">
  <time datetime="2022-10-18T05:29:45.000Z" itemprop="datePublished">2022-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/18/%E5%9F%BA%E4%BA%8Eriscv%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/">基于riscv使用汇编实现简单的任务调度</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>本文主要通过简单的代码实现，线程的上下文保存和切换，实现一个简单的多线程框架，线程的调度只是使用了一个轮询的方法。</p>
<h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><p>对于一个运行中的程序, 我们可以把它看作一个状态机, CPU每次执行一条指令会导致这个状态机从一个状态转换到另一个状态, 而这里的状态就是CPU的寄存器值和当前时刻内存的状态, 即state = (Regs, Mem). 一个程序的执行过程就是状态机状态迁移的过程, 如果希望在一个线程执行过程到某条指令时切换到另一个线程, 我们必须额外实现一段代码去完成这种切换, 并把这段代码插入到希望的切换点的后面, 这段代码必须要满足两个条件: </p>
<p>1): 能够正确保存当前线程A的状态. 我们可以先假设完成这段切换的代码不存在, 线程A本该执行它的下一条指令, 而在执行下一条指令之前, 线程A有一个确定的状态, 即CPU的寄存器和内存中的值, <strong>具体来说包括pc指针, 栈寄存器sp, 通用寄存器等以及线程使用到的内存的状态.</strong> 线程切换代码, 首先必须能够当前线程A的状态保存起来, 以便后续调度器再切换回当前的这个线程. </p>
<p>2): 能够正确恢复被选中的线程B的状态. 为了切换到另一个线程B去执行, 我<strong>们必须从保存线程B状态的内存地址处读取线程B的状态, 然后更新CPU寄存器以及内存的状态,</strong> 更新完成之后就可以继续线程B被中断的执行流了. 这里保存和恢复的线程状态就是线程的上下文, 在一个线程还没有运行过的情况下, 我们需要手工构造一个线程的上下文, 这个上下文的作用是使得线程一旦被调度, 就能够从创建线程时指定的入口地址处执行</p>
<h2 id="保存上下文"><a href="#保存上下文" class="headerlink" title="保存上下文"></a>保存上下文</h2><p>真个汇编代码的逻辑就是首先保存当前线程的上下文，在切换要执行线程的上下文。</p>
<p>以下都以RISC-V为基础进行讨论. 从线程A的角度看, 当它在自己的正常执行流中调用我们实现的上下文切换代码时, 只是相当于调用了一个普通函数, 因此编译器会根据RISC-V架构的ABI约定, 在调用这个函数之前去保存caller saved registers, 即ABI约定中应该由调用者去保存的寄存器, 并且在调用结束之后插入恢复这些寄存器的指令序列, 上下文切换代码段首先要做的就是保存ABI中约定由被调用者保存的寄存器, 我们可以在表示线程的结构体中开辟一块区域用来保存这些寄存器, 具体实现可以定义一个描述上下文的结构体, 并在线程结构体中嵌入一个上下文描述结构体.</p>
<h2 id="切换上下文"><a href="#切换上下文" class="headerlink" title="切换上下文"></a>切换上下文</h2><p>线程切换代码段的下一个任务是恢复线程B的状态到CPU和内存, 只要使用若干load指令去恢复线程B的寄存器状态即可, 最后使用调用返回指令ret就完成了线程的切换. ret指令会根据ra寄存器的值更新pc寄存器, 从而完成跳转, 而ra寄存器保存了线程B被中断的那条指令的地址, 需要注意的是, 在RISC-V架构下, 我们无法通过类似mv这样的指令直接修改pc寄存器的值.</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>进入到main函数之后, 首先创将两个线程, 然后调用本文实现调度模块提供的接口对线程列表中的线程进行调度, 直到没有可供调度的线程.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;  </span><br><span class="line">	qthread_create(thread1_start);     </span><br><span class="line">	qthread_create(thread2_start);     </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Start to run all threads...n&quot;</span>);     </span><br><span class="line">	qthread_run_all();     </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;All threads are done!n&quot;</span>);      </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>两个线程的入口函数分别为<code>thread1_start</code>和<code>thread2_start</code>, 线程完成的任务如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread1_start</span><span class="params">(<span class="type">void</span> *args)</span> &#123;     </span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;     </span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">    	<span class="keyword">if</span> ((i % <span class="number">100</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;Thread #1: runningn&quot;</span>);             </span><br><span class="line">        	qthread_yield();         </span><br><span class="line">        &#125;         </span><br><span class="line">        i++;     </span><br><span class="line">    &#125;     </span><br><span class="line">    qthread_exit();     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>两个线程的入口函数功能类似, 都会在使用占用一段时间的CPU之后主动放弃使用权, 任务完成之后主动退出, 在CM32M433R开发板运行可以得到运行结果:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Start to run all threads...</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">Thread #1: running</span><br><span class="line">Thread #2: running</span><br><span class="line">All threads are done!</span><br></pre></td></tr></table></figure>

<h3 id="线程调度模块的具体接口"><a href="#线程调度模块的具体接口" class="headerlink" title="线程调度模块的具体接口"></a>线程调度模块的具体接口</h3><p>对于本文实现的线程调度模块qthread，其对外的接口主要包括创建，运行，挂起，结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">qthread_create</span><span class="params">(<span class="type">qthread_entry_t</span> entry)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">qthread_yield</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">qthread_exit</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">qthread_run_all</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="线程描述的结构体"><a href="#线程描述的结构体" class="headerlink" title="线程描述的结构体"></a>线程描述的结构体</h3><p>为了管理创建出来的线程, 需要一个描述线程的结构体, 记录线程的id, 调度状态, 线程上下文等信息. 需要注意的是, 每个线程的运行都需要栈的支持, 这里在线程结构体中定义了一个1024字节大小的数组, 用于线程函数运行使用的栈, 在创建线程时, 会手动设置线程上下文中的sp指针的值.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	uint64 tid;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">thread_state</span> <span class="title">state</span>;</span></span><br><span class="line">	<span class="type">qthread_entry_t</span> qthread_entry;</span><br><span class="line">	<span class="type">char</span> <span class="built_in">stack</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span></span><br><span class="line">&#125; <span class="type">qthread_t</span>;</span><br></pre></td></tr></table></figure>

<p>创建线程的接口实现如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">qthread_create</span><span class="params">(<span class="type">qthread_entry_t</span> entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index_found = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_THREADS_NR; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (qthread_table[i].state == UNUSED)</span><br><span class="line">        &#123;</span><br><span class="line">            index_found = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index_found &lt; <span class="number">0</span> || index_found &gt;= MAX_THREADS_NR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qthread_table[index_found].tid = get_next_tid();</span><br><span class="line">    qthread_table[index_found].state = READY;</span><br><span class="line">    qthread_table[index_found].qthread_entry = entry;</span><br><span class="line"></span><br><span class="line">    qthread_table[index_found].context.ra = (uint64)entry;</span><br><span class="line">    qthread_table[index_found].context.sp = (uint64)qthread_table[index_found].<span class="built_in">stack</span> + <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为栈的增长方向是由高地址向低地址, 所以线程上下文中的sp指针赋值时需要加上栈的大小, 否则会出现栈溢出的问题.</p>
<h3 id="上下文描述结构体"><a href="#上下文描述结构体" class="headerlink" title="上下文描述结构体"></a>上下文描述结构体</h3><p>对于RISC-V架构, 在进行上下文切换时需要保存ABI约定中callee维护的寄存器外加<code>ra</code>寄存器, 因为<code>ra</code>寄存器记录了调用完线程切换代码段对应的函数之后的返回地址, 即线程A被打断的指令地址. 上下文描述结构体如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    uint64 ra;  <span class="comment">// x1 </span></span><br><span class="line">    uint64 sp;  <span class="comment">// x2</span></span><br><span class="line">    uint64 s0;  <span class="comment">// x8</span></span><br><span class="line">    uint64 s1;  <span class="comment">// x9</span></span><br><span class="line">    uint64 s2;  <span class="comment">// x18 - x27</span></span><br><span class="line">    uint64 s3;  <span class="comment">// </span></span><br><span class="line">    uint64 s4;  <span class="comment">//</span></span><br><span class="line">    uint64 s5;</span><br><span class="line">    uint64 s6;</span><br><span class="line">    uint64 s7;</span><br><span class="line">    uint64 s8;</span><br><span class="line">    uint64 s9;</span><br><span class="line">    uint64 s10;</span><br><span class="line">    uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="线程切换代码段"><a href="#线程切换代码段" class="headerlink" title="线程切换代码段"></a>线程切换代码段</h3><p>如上文所述, 线程切换代码段需要保存一个上下文, 并恢复另一个上下文, 这部分代码使用汇编指令去实现，这是riscv32的指令，如果时64位则是ld和sd，并且要保存浮点寄存器:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">	.section .text</span><br><span class="line">    .global swtch</span><br><span class="line">swtch:</span><br><span class="line">    sw ra, <span class="number">0</span>(a0)</span><br><span class="line">    sw sp, <span class="number">4</span>(a0)</span><br><span class="line">    sw s0, <span class="number">8</span>(a0)</span><br><span class="line">    sw s1, <span class="number">12</span>(a0)</span><br><span class="line">    sw s2, <span class="number">16</span>(a0)</span><br><span class="line">    sw s3, <span class="number">20</span>(a0)</span><br><span class="line">   	sw s4, <span class="number">24</span>(a0)</span><br><span class="line">    sw s5, <span class="number">28</span>(a0)</span><br><span class="line">    sw s6, <span class="number">32</span>(a0)</span><br><span class="line">    sw s7, <span class="number">36</span>(a0)</span><br><span class="line">    sw s8, <span class="number">40</span>(a0)</span><br><span class="line">    sw s9, <span class="number">44</span>(a0)</span><br><span class="line">    sw s10, <span class="number">48</span>(a0)</span><br><span class="line">    sw s11, <span class="number">52</span>(a0)</span><br><span class="line"></span><br><span class="line">    lw ra, <span class="number">0</span>(a1)</span><br><span class="line">    lw sp, <span class="number">4</span>(a1)</span><br><span class="line">    lw s0, <span class="number">8</span>(a1)</span><br><span class="line">    lw s1, <span class="number">12</span>(a1)</span><br><span class="line">    lw s2, <span class="number">16</span>(a1)</span><br><span class="line">    lw s3, <span class="number">20</span>(a1)</span><br><span class="line">    lw s4, <span class="number">24</span>(a1)</span><br><span class="line">    lw s5, <span class="number">28</span>(a1)</span><br><span class="line">    lw s6, <span class="number">32</span>(a1)</span><br><span class="line">    lw s7, <span class="number">36</span>(a1)</span><br><span class="line">    lw s8, <span class="number">40</span>(a1)</span><br><span class="line">    lw s9, <span class="number">44</span>(a1)</span><br><span class="line">    lw s10, <span class="number">48</span>(a1)</span><br><span class="line">    lw s11, <span class="number">52</span>(a1)</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>代码的前半部分用于保存上下文, 后半部分用于恢复上下文, 按照ABI约定, 寄存器<code>a0</code>和<code>a1</code>分别用来传递函数调用的第一个和第二个参数, 这里在调用时传递的就是两段保存和恢复各自上下文的内存地址. 最后的<code>ret</code>指令, 会用寄存器<code>ra</code>的值更新寄存器<code>pc</code>, 因为<code>ra</code>已经被恢复成了线程B被中断的指令地址, 所以<code>ret</code>指令执行过后CPU就会执行线程B对应的代码. 在恢复上下文时也更新了栈指针寄存器<code>sp</code>, 所以线程B在执行时使用的时自己的栈内存. 线程主动释放CPU资源时会调用<code>qthread_yield()</code>, 在这个函数中会调用线程切换函数<code>swtch</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qthread_yield</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    current-&gt;state = READY;</span><br><span class="line">    swtch(&amp;current-&gt;context, &amp;qthread_context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于调用<code>qthread_yield()</code>的线程A来说, 当其内部调用<code>swtch</code>函数时, 实际上CPU已经切换到了另一个线程B去执行, 但线程A是不能感知到的, 当这个<code>swtch</code>函数返回之后, 对线程A来说就像调用了一个普通的函数一样, 线程A会继续自己的执行流.</p>
<h3 id="轮询调度实现"><a href="#轮询调度实现" class="headerlink" title="轮询调度实现"></a>轮询调度实现</h3><p>调度采用轮询的方式, 每次选取一个可用线程去切换.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qthread_run_all</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_THREADS_NR; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (qthread_table[i].state == READY)</span><br><span class="line">            &#123;</span><br><span class="line">                current = &amp;qthread_table[i];</span><br><span class="line">                current-&gt;state = RUNNING;</span><br><span class="line">                count++;</span><br><span class="line">                swtch(&amp;qthread_context, &amp;current-&gt;context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：<a target="_blank" rel="noopener" href="http://www.itfaba.com/jishufenxian/36908.html">http://www.itfaba.com/jishufenxian/36908.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/18/%E5%9F%BA%E4%BA%8Eriscv%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/" data-id="cl9dtq1p20000ckmj11q942i8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Linux内存管理-slab原理以及buddy伙伴系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/12/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-slab%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Abuddy%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time datetime="2022-10-12T07:54:40.000Z" itemprop="datePublished">2022-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/12/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-slab%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Abuddy%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/">Linux内存管理:slab原理以及buddy伙伴系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-为什么有了Buddy-伙伴系统-还需要slab"><a href="#1-为什么有了Buddy-伙伴系统-还需要slab" class="headerlink" title="1 为什么有了Buddy(伙伴系统)还需要slab?"></a>1 为什么有了Buddy(伙伴系统)还需要slab?</h2><h3 id="1-1-什么是伙伴系统？"><a href="#1-1-什么是伙伴系统？" class="headerlink" title="1.1 什么是伙伴系统？"></a>1.1 什么是伙伴系统？</h3><p>Linux内核中使用伙伴系统（buddy system）算法以页为单位管理内存，进行内存分配。</p>
<h3 id="1-1-1-伙伴系统思想"><a href="#1-1-1-伙伴系统思想" class="headerlink" title="1.1.1 伙伴系统思想"></a>1.1.1 伙伴系统思想</h3><p>它把所有的空闲页放到11个链表中，每个链表分别管理大小为1，2，4，8，16，32，64，128，256，512，1024个页的内存块。当系统需要分配内存时，就可以从buddy系统中获取。</p>
<h3 id="1-2-伙伴系统例子说明"><a href="#1-2-伙伴系统例子说明" class="headerlink" title="1.2 伙伴系统例子说明"></a>1.2 伙伴系统例子说明</h3><p>例如，要申请一块包含4个页的连续内存，就直接从buddy系统中管理4个页连续内存的链表中获取。同样的，如果系统需要申请3个页的连续内存，则只能在4个页的链表中获取，剩下的一个页被放到buddy系统中管理1个页的链表中。</p>
<h3 id="1-3-伙伴系统能解决的问题"><a href="#1-3-伙伴系统能解决的问题" class="headerlink" title="1.3 伙伴系统能解决的问题"></a>1.3 伙伴系统能解决的问题</h3><p>Buddy 系统解决了物理内存分配的外部碎片问题。</p>
<p>Linux内存管理 - buddy系统<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/longchang/p/10749392.html">https://www.cnblogs.com/longchang/p/10749392.html</a></p>
<h2 id="2-为什么需要引入slab算法？"><a href="#2-为什么需要引入slab算法？" class="headerlink" title="2 为什么需要引入slab算法？"></a>2 为什么需要引入slab算法？</h2><h3 id="2-1-伙伴系统的缺点"><a href="#2-1-伙伴系统的缺点" class="headerlink" title="2.1 伙伴系统的缺点"></a>2.1 伙伴系统的缺点</h3><p>Buddy提供了以page为单位的内存分配接口，这对内核来说颗粒度还太大了，所以需要一种新的机制，将page拆分为更小的单位来管理。</p>
<h3 id="2-2-伙伴系统的缺点例子说明"><a href="#2-2-伙伴系统的缺点例子说明" class="headerlink" title="2.2 伙伴系统的缺点例子说明"></a>2.2 伙伴系统的缺点例子说明</h3><p>Linux内存以页为单位进行内存管理，buddy算法以2的n次方个页面来进行内存分配管理，最小为20，也就是一页，最大为211，就是4MB大小的连续内存空间。但是页的粒度还是太大，Linux下是4KB大小，也就是4096个字节，而kernel本身有很多数据结构时时刻刻都需要分配或者释放，这些数据的大小又往往小于4KB大小，一般只有几个几十个字节这样的大小。<br>比方最常用到的task_struct（进程描述符）结构体和mm_struct（内存描述符）结构体，其中，izeof task_struct = 9152,sizeof mm_struct = 2064。</p>
<p>task_struct稍微大一点将近2个页面，mm_struct就只有差不多半个页面了。这样一来如果所有的这些数据结构都按照页来分配存储和管理，那么我相信kernel过不了多久自己就玩完了，内存碎片肯定一堆一堆。</p>
<p>所以，引入slab分配器是为了弥补内存管理粒度太大的不足。</p>
<h2 id="3-slab-能解决什么问题？"><a href="#3-slab-能解决什么问题？" class="headerlink" title="3 slab 能解决什么问题？"></a>3 slab 能解决什么问题？</h2><p>slab分配需要解决的是内存的内部碎片问题。<br>所谓内部碎片就是指被内核分配出去但是不能被利用的内存。<br>而外部碎片是指由于频繁地申请和释放页框而导致的某些小的连续页框，比方只有一个页框，无法分配给需要大的连续页框的进程而导致的内存碎片。</p>
<h3 id="3-0-slab-分配例子"><a href="#3-0-slab-分配例子" class="headerlink" title="3.0 slab 分配例子"></a>3.0 slab 分配例子</h3><p>比如我需要一个100字节的连续物理内存，那么内核slab分配器会给我提供一个相应大小的连续物理内存单元，为128字节大小(不会是整好100字节，而是这个档的一个对齐值，如100字节对应128字节，30字节对应32字节，60字节对应64字节)</p>
<h2 id="4-slab系统核心思想是什么？"><a href="#4-slab系统核心思想是什么？" class="headerlink" title="4 slab系统核心思想是什么？"></a>4 slab系统核心思想是什么？</h2><h3 id="4-0-须知："><a href="#4-0-须知：" class="headerlink" title="4.0. 须知："></a>4.0. 须知：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache： 内存池</span><br><span class="line">slab：       内存池从系统申请内存的基本单位</span><br><span class="line">object：     内存池提供的内存的单位</span><br></pre></td></tr></table></figure>

<h3 id="4-1-slab核心思想：对象管理内存（简单说：就是你经常用什么我先给你创造一堆出来，你要用直接拿，不用放回来）"><a href="#4-1-slab核心思想：对象管理内存（简单说：就是你经常用什么我先给你创造一堆出来，你要用直接拿，不用放回来）" class="headerlink" title="4.1 slab核心思想：对象管理内存（简单说：就是你经常用什么我先给你创造一堆出来，你要用直接拿，不用放回来）"></a>4.1 slab核心思想：对象管理内存（简单说：就是你经常用什么我先给你创造一堆出来，你要用直接拿，不用放回来）</h3><p>使用对象的概念来管理内存。</p>
<p>slab分配器的基本思想是，先利用页面分配器分配出单个或者一组连续的物理页面，然后在此基础上将整块页面分割成多个相等的小内存单元，以满足小内存空间分配的需要。当然，为了有效的管理这些小的内存单元并保证极高的内存使用速度和效率。</p>
<p>这段话摘自：《深入linux设备驱动程序内核机制》<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuzhihui_no1/article/details/47305361">https://blog.csdn.net/yuzhihui_no1/article/details/47305361</a></p>
<h3 id="4-2-slab的对象-内存池思想"><a href="#4-2-slab的对象-内存池思想" class="headerlink" title="4.2 slab的对象/内存池思想"></a>4.2 slab的对象/内存池思想</h3><p>在内核中，经常会使用一些链表，链表中会申请许多相同结构的结构体，比如文件对象，进程对象等等，如果申请比较频繁，那么为它们建立一个内存池，内存池中都是相同结构的结构体，当想申请这种结构体时，直接从这种内存池中取一个结构体出来，是有用且速度极快的。一个物理页就可以作用这种内存池的载体，进而进行充分利用，减少了内部碎片的产生。</p>
<p>所以，Slab 相当于内存池思想，且是为了解决内碎片而产生的，slab的核心思想是以对象的观点管理内存。</p>
<h3 id="4-3-slab中对象是什么？"><a href="#4-3-slab中对象是什么？" class="headerlink" title="4.3 slab中对象是什么？"></a>4.3 slab中对象是什么？</h3><p>所谓的对象就是存放一组数据结构的内存区，为便于理解可把对象看作内核中的数据结构（例如：task_struct,file_struct 等）。</p>
<p>相同类型的对象归为一类，每当要申请这样一个对象时，slab分配器就从一个slab列表中分配一个这样大小的单元出去，而当要释放时，将其重新保存在该列表中，而不是直接返回给伙伴系统，从而避免内部碎片。</p>
<h3 id="4-4-cache是内存中的区域，而不是指硬件高速缓存"><a href="#4-4-cache是内存中的区域，而不是指硬件高速缓存" class="headerlink" title="4.4 cache是内存中的区域，而不是指硬件高速缓存"></a>4.4 cache是内存中的区域，而不是指硬件高速缓存</h3><p>这种场景是非常多的，为了应对这种场景，slab为这样的对象创建一个cache，即缓存。每个cache所占的内存区又被划分多个slab，每个 slab是由一个或多个连续的页框组成。每个页框中包含若干个对象，既有已经分配的对象，也包含空闲的对象。</p>
<p>尽管英文中使用了Cache这个词，但实际上指的是内存中的区域，而不是指硬件高速缓存</p>
<h3 id="4-5-slab分配器的一个基本原则"><a href="#4-5-slab分配器的一个基本原则" class="headerlink" title="4.5 slab分配器的一个基本原则"></a>4.5 slab分配器的一个基本原则</h3><p>slab分配器对不同长度内存是分档的，这是slab分配器的一个基本原则，按申请的内存的大小分配相应长度的内存。</p>
<p>这可以先参考kmalloc的实现，kmalloc申请的物理内存长度为参数size，它需要先根据这个长度找到相应的长度的缓存<br>slab分配器并非一开始就能智能的根据内存分档值分配相应长度的内存。每种cache对应一种长度的slab分配。</p>
<h2 id="5-slab分配的最小和最大内存单元是多少"><a href="#5-slab分配的最小和最大内存单元是多少" class="headerlink" title="5 slab分配的最小和最大内存单元是多少?"></a>5 slab分配的最小和最大内存单元是多少?</h2><p>23、………211个字节。<br>另外还有两个特殊的组，分别是96B和192B，共11组</p>
<p>所以，slab分配内存大小是：<br>8B，16B，32B，64B，96B，128B，192B，256B，512B，1024B，2048B等大小。共11组</p>
<h3 id="5-1-cat-proc-slabinfo-查看系统中的slab对象"><a href="#5-1-cat-proc-slabinfo-查看系统中的slab对象" class="headerlink" title="5.1 cat /proc/slabinfo 查看系统中的slab对象"></a>5.1 cat /proc/slabinfo 查看系统中的slab对象</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost 10]# cat /proc/slabinfo</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name  &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line"></span><br><span class="line">rpc_inode_cache       51     51    640   51    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">xfs_dqtrx              0      0    528   62    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">xfs_dquot              0      0    488   67    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">xfs_ili             2160   2160    168   48    2 : tunables    0    0    0 : slabdata     45     45      0</span><br><span class="line">xfs_inode          21352  21352    960   34    8 : tunables    0    0    0 : slabdata    628    628      0</span><br><span class="line">xfs_efd_item         156    156    416   39    4 : tunables    0    0    0 : slabdata      4      4      0</span><br><span class="line">xfs_btree_cur         39     39    208   39    2 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">xfs_log_ticket        44     44    184   44    2 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">bio-2                 51     51    320   51    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">kcopyd_job             0      0   3312    9    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dm_uevent              0      0   2608   12    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dm_rq_target_io        0      0    136   60    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">ip6_dst_cache         72     72    448   36    4 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">RAWv6                286    286   1216   26    8 : tunables    0    0    0 : slabdata     11     11      0</span><br><span class="line">UDPLITEv6              0      0   1216   26    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">UDPv6                 26     26   1216   26    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">tw_sock_TCPv6          0      0    256   64    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">TCPv6                 15     15   2176   15    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">cfq_queue             70     70    232   70    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">bsg_cmd                0      0    312   52    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">mqueue_inode_cache    36     36    896   36    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">hugetlbfs_inode_cache 53     53    608   53    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">configfs_dir_cache     0      0     88   46    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dquot                  0      0    256   64    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">userfaultfd_ctx_cache  0      0    192   42    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">fanotify_event_info   73     73     56   73    1 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">pid_namespace          0      0   2200   14    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">posix_timers_cache    66     66    248   66    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">UDP-Lite               0      0   1088   30    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">flow_cache             0      0    144   56    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">xfrm_dst_cache         0      0    576   56    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">UDP                   30     30   1088   30    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">tw_sock_TCP            0      0    256   64    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">TCP                   16     16   1984   16    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">dax_cache             42     42    768   42    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">blkdev_queue          26     26   2424   13    8 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">blkdev_ioc            78     78    104   39    1 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">user_namespace        68     68    480   68    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">dmaengine-unmap-128     30     30   1088   30    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">sock_inode_cache    1020   1020    640   51    8 : tunables    0    0    0 : slabdata     20     20      0</span><br><span class="line">fsnotify_mark_connector 129370 129370     24  170    1 : tunables    0    0    0 : slabdata    761    761      0</span><br><span class="line">net_namespace          6      6   5248    6    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">shmem_inode_cache   1200   1200    680   48    8 : tunables    0    0    0 : slabdata     25     25      0</span><br><span class="line">Acpi-ParseExt       6440   6440     72   56    1 : tunables    0    0    0 : slabdata    115    115      0</span><br><span class="line">Acpi-State           102    102     80   51    1 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">task_delay_info      288    288    112   36    1 : tunables    0    0    0 : slabdata      8      8      0</span><br><span class="line">taskstats             49     49    328   49    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">proc_inode_cache    1621   1813    656   49    8 : tunables    0    0    0 : slabdata     37     37      0</span><br><span class="line">sigqueue              51     51    160   51    2 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">bdev_cache            39     39    832   39    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">kernfs_node_cache  35360  35360    120   68    2 : tunables    0    0    0 : slabdata    520    520      0</span><br><span class="line">mnt_cache           2478   2478    384   42    4 : tunables    0    0    0 : slabdata     59     59      0</span><br><span class="line">inode_cache        16720  16720    592   55    8 : tunables    0    0    0 : slabdata    304    304      0</span><br><span class="line">dentry             49350  49350    192   42    2 : tunables    0    0    0 : slabdata   1175   1175      0</span><br><span class="line">iint_cache             0      0    128   64    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">selinux_inode_security  45798  45798     40  102    1 : tunables    0    0    0 : slabdata    449    449      0</span><br><span class="line">buffer_head         2145   2145    104   39    1 : tunables    0    0    0 : slabdata     55     55      0</span><br><span class="line">vm_area_struct      4699   4699    216   37    2 : tunables    0    0    0 : slabdata    127    127      0</span><br><span class="line">mm_struct             60     60   1600   20    8 : tunables    0    0    0 : slabdata      3      3      0</span><br><span class="line">files_cache          204    204    640   51    8 : tunables    0    0    0 : slabdata      4      4      0</span><br><span class="line">signal_cache         252    252   1152   28    8 : tunables    0    0    0 : slabdata      9      9      0</span><br><span class="line">sighand_cache        255    255   2112   15    8 : tunables    0    0    0 : slabdata     17     17      0</span><br><span class="line">task_xstate          273    273    832   39    8 : tunables    0    0    0 : slabdata      7      7      0</span><br><span class="line">task_struct          255    264   4048    8    8 : tunables    0    0    0 : slabdata     33     33      0</span><br><span class="line">anon_vma            1887   1887     80   51    1 : tunables    0    0    0 : slabdata     37     37      0</span><br><span class="line">shared_policy_node   2635   2635     48   85    1 : tunables    0    0    0 : slabdata     31     31      0</span><br><span class="line">numa_policy          186    186    264   62    4 : tunables    0    0    0 : slabdata      3      3      0</span><br><span class="line">radix_tree_node     2856   2856    584   56    8 : tunables    0    0    0 : slabdata     51     51      0</span><br><span class="line">idr_layer_cache      180    180   2112   15    8 : tunables    0    0    0 : slabdata     12     12      0</span><br><span class="line">dma-kmalloc-8192       0      0   8192    4    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-4096       0      0   4096    8    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-2048       0      0   2048   16    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-1024       0      0   1024   32    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-512       64     64    512   64    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">dma-kmalloc-256        0      0    256   64    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-128        0      0    128   64    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-64         0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-32         0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-16         0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-8          0      0      8  512    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-192        0      0    192   42    2 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">dma-kmalloc-96         0      0     96   42    1 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">kmalloc-8192          40     40   8192    4    8 : tunables    0    0    0 : slabdata     10     10      0</span><br><span class="line">kmalloc-4096         254    264   4096    8    8 : tunables    0    0    0 : slabdata     33     33      0</span><br><span class="line">kmalloc-2048         955   1072   2048   16    8 : tunables    0    0    0 : slabdata     67     67      0</span><br><span class="line">kmalloc-1024        2894   2976   1024   32    8 : tunables    0    0    0 : slabdata     93     93      0</span><br><span class="line">kmalloc-512         4825   4864    512   64    8 : tunables    0    0    0 : slabdata     76     76      0</span><br><span class="line">kmalloc-256         7406   7552    256   64    4 : tunables    0    0    0 : slabdata    118    118      0</span><br><span class="line">kmalloc-192         7560   7560    192   42    2 : tunables    0    0    0 : slabdata    180    180      0</span><br><span class="line">kmalloc-128         3136   3136    128   64    2 : tunables    0    0    0 : slabdata     49     49      0</span><br><span class="line">kmalloc-96          5334   5334     96   42    1 : tunables    0    0    0 : slabdata    127    127      0</span><br><span class="line">kmalloc-64         84850  85184     64   64    1 : tunables    0    0    0 : slabdata   1331   1331      0</span><br><span class="line">kmalloc-32        125696 125696     32  128    1 : tunables    0    0    0 : slabdata    982    982      0</span><br><span class="line">kmalloc-16         63232  63232     16  256    1 : tunables    0    0    0 : slabdata    247    247      0</span><br><span class="line">kmalloc-8          86528  86528      8  512    1 : tunables    0    0    0 : slabdata    169    169      0</span><br><span class="line">kmem_cache_node      128    128     64   64    1 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">kmem_cache           128    128    256   64    4 : tunables    0    0    0 : slabdata      2      2      0</span><br><span class="line">[root@localhost 10]#</span><br></pre></td></tr></table></figure>

<h2 id="6-slab与buddy系统的关系"><a href="#6-slab与buddy系统的关系" class="headerlink" title="6 slab与buddy系统的关系"></a>6 slab与buddy系统的关系</h2><h3 id="6-1-互补的"><a href="#6-1-互补的" class="headerlink" title="6.1 互补的"></a>6.1 互补的</h3><p>slab系统与buddy系统所要解决的问题是互补的，一个解决外部碎片一个解决内部碎片，但事实上，slab在新建cache时同样需要用到buddy来为之分配页面，而在释放cache时也需要buddy来回收这此页面。也就是说，slab事实上是依赖buddy系统的。</p>
<h3 id="6-2-实际还是伙伴系统分配物理页"><a href="#6-2-实际还是伙伴系统分配物理页" class="headerlink" title="6.2 实际还是伙伴系统分配物理页"></a>6.2 实际还是伙伴系统分配物理页</h3><p>从slab的分配可以知道，其实所有的内存最终还是要伙伴系统来分配，这里就可以知道，这些内存都是连续的物理页。</p>
<h3 id="6-3-slab作为内核缓存对象"><a href="#6-3-slab作为内核缓存对象" class="headerlink" title="6.3 slab作为内核缓存对象"></a>6.3 slab作为内核缓存对象</h3><p>在某些情况下内核模块可能需要频繁的分配和释放相同的内存对象，这时候slab可以作为内核对象的缓存，当slab对象被释放时，slab分配器并不会把对象占用的物理空间还给伙伴系统。这样的好处是当内核模块需要再次分配内存对象时，不需要那么麻烦的向伙伴系统申请，而是可以直接在slab链表中分配一个合适的对象</p>
<h2 id="7-slab-配器结构"><a href="#7-slab-配器结构" class="headerlink" title="7 slab 配器结构"></a>7 slab 配器结构</h2><h3 id="7-1-slab-结构图"><a href="#7-1-slab-结构图" class="headerlink" title="7.1 slab 结构图"></a>7.1 slab 结构图</h3><p>图：</p>
<p><img src="/2022/10/12/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-slab%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Abuddy%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/image-20221012160254149.png" alt="image-20221012160254149"></p>
<p>解释：<br>每个kmem_cache都是链接在一起形成一个全局的双向链表，由cache指向该链表，系统可以从Cache_chain开始扫描每个kmem_cache，来找到一个大小最合适的kmem_cache，然后从该kmem_cache中分配一个对象</p>
<h3 id="7-2-slab-结构解释"><a href="#7-2-slab-结构解释" class="headerlink" title="7.2 slab 结构解释"></a>7.2 slab 结构解释</h3><h3 id="7-2-1-cache-chain"><a href="#7-2-1-cache-chain" class="headerlink" title="7.2.1 cache_chain"></a>7.2.1 cache_chain</h3><p>最高层是 cache_chain,这是一个 slab 缓存的链接列表。可以用来查找最适合所需要的分配大小的缓存（遍历列表）<br>cache_chain 的每个元素都是一个 kmem_cache 结构的引用（称为一个 cache）。它定义了一个要管理的给定大小的对象池。</p>
<h3 id="7-2-2-kmem-cache"><a href="#7-2-2-kmem-cache" class="headerlink" title="7.2.2 kmem_cache"></a>7.2.2 kmem_cache</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kmem_cache： 内存池</span><br><span class="line">slab：       内存池从系统申请内存的基本单位</span><br><span class="line">object：     内存池提供的内存的单位</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-1-kmem-cache-或-cache："><a href="#7-2-2-1-kmem-cache-或-cache：" class="headerlink" title="7.2.2.1 kmem_cache 或 cache："></a>7.2.2.1 kmem_cache 或 cache：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有的地方也会叫这个kmem_cache为cache，原因是kmem_cache中的object有大有小（其实也是kmem_cache有大有小），</span><br><span class="line">当内存申请时，会有命中该kmem_cache的说法，和CPU中的cache命中是类似的意思，所以也会叫kmem_cache为cache</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-2-三条链表：slabs-full-slabs-partial-slabs-empty"><a href="#7-2-2-2-三条链表：slabs-full-slabs-partial-slabs-empty" class="headerlink" title="7.2.2.2 三条链表：slabs_full slabs_partial slabs_empty"></a>7.2.2.2 三条链表：slabs_full slabs_partial slabs_empty</h3><p>每个缓存(kmem_cache)都包含了一个 slabs 列表，这是一段连续的内存块（通常都是页面）<br>其中每个kmem_cache有三条链表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slabs_full 表示该链表中每个slab的object对象都已经分配完了</span><br><span class="line">slabs_partial 表示该链表中的slab的object对象部分分配完了</span><br><span class="line">slabs_empty  表示该链表中的object对象全部没有分配出去（空 slab，未分配）</span><br></pre></td></tr></table></figure>


<p>对象的分配和释放都是在slab中进行的，所以slab可以在三条链表中移动，如果slab中的object都分配完了，则会移到full 链表中；如果分配了一部分object，则会移到partial链表中；如果所有object都释放了，则会移动到empty链表中；其中当系统内存紧张的时候，slabs_empty链表中的slab可能会被返回给系统。</p>
<h4 id="7-2-2-3-cache-cache-结构体等说明"><a href="#7-2-2-3-cache-cache-结构体等说明" class="headerlink" title="7.2.2.3 cache_cache 结构体等说明"></a>7.2.2.3 cache_cache 结构体等说明</h4><p>所有的kmem_cache结构都是从cache_cache分配的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">kmem_cache_t</span> cache_cache = &#123;</span><br><span class="line">     slabs_full:     LIST_HEAD_INIT(cache_cache.slabs_full),</span><br><span class="line">     slabs_partial:  LIST_HEAD_INIT(cache_cache.slabs_partial),</span><br><span class="line">     slabs_free:     LIST_HEAD_INIT(cache_cache.slabs_free),</span><br><span class="line">     objsize:        <span class="keyword">sizeof</span>(<span class="type">kmem_cache_t</span>),</span><br><span class="line">     flags:          SLAB_NO_REAP,</span><br><span class="line">     spinlock:       SPIN_LOCK_UNLOCKED,</span><br><span class="line">     colour_off:     L1_CACHE_BYTES,</span><br><span class="line">     name:           <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_size</span>&#123;</span></span><br><span class="line">	<span class="type">size_t</span> cs_size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">cs_cachep</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_size</span> <span class="title">malloc_sizes</span>[] =</span> &#123; </span><br><span class="line">	&#123;.cs_size = <span class="number">32</span>&#125;,</span><br><span class="line">	&#123;.cs_size = <span class="number">64</span>&#125;,</span><br><span class="line">	&#123;.cs_size = <span class="number">128</span>&#125;,</span><br><span class="line">	&#123;.cs_size = <span class="number">256</span>&#125;,</span><br><span class="line">	................</span><br><span class="line">	&#123;.cs_size = ~<span class="number">0UL</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在系统初始化时，内核会调用kmem_cache_init函数对malloc_size数组进行遍历，对数组中的每个元素都调用kmem_cache_create()函数在cache_cache中分配一个struct kmem_cache 实例，并且把kmem_cache所在的地址赋值给cache_size中的cs_cachep指针</p>
<h3 id="7-2-3-slab"><a href="#7-2-3-slab" class="headerlink" title="7.2.3 slab"></a>7.2.3 slab</h3><p>slab 列表中的每个 slab 都是一个连续的内存块（一个或多个连续页），它们被划分成一个个对象（如 mm_struct）。<br>这些对象是从特定缓存中进行分配和释放的基本元素。</p>
<h2 id="8-slab-和-proc"><a href="#8-slab-和-proc" class="headerlink" title="8 slab 和 /proc"></a>8 slab 和 /proc</h2><p>proc 文件系统提供了一种简单的方法来监视系统中所有活动的 slab 缓存。<br>这个文件称为 /proc/slabinfo，<br>它除了提供一些可以从用户空间访问的可调整参数之外，还提供了有关所有 slab 缓存的详细信息。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost home]# cat  /proc/slabinfo</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;<span class="built_in">limit</span>&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">nf_conntrack_ffffffffb58fc900     51     51    320   51    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">rpc_inode_cache       51     51    640   51    8 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">xfs_dqtrx              0      0    528   62    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">xfs_dquot              0      0    488   67    8 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">xfs_ili             2016   2016    168   48    2 : tunables    0    0    0 : slabdata     42     42      0</span><br><span class="line">xfs_inode          21182  21182    960   34    8 : tunables    0    0    0 : slabdata    623    623      0</span><br><span class="line">xfs_efd_item          39     39    416   39    4 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">xfs_btree_cur         39     39    208   39    2 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="9-slab-API"><a href="#9-slab-API" class="headerlink" title="9 slab API"></a>9 slab API</h2><p>Linux内存管理之slab 2：slab API<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqy971966/article/details/119801912">https://blog.csdn.net/lqy971966/article/details/119801912</a></p>
<p>参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuzhihui_no1/article/details/47305361">https://blog.csdn.net/yuzhihui_no1/article/details/47305361</a></p>
<p><strong>转载于：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lqy971966/article/details/112980005">https://blog.csdn.net/lqy971966/article/details/112980005</a></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/12/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-slab%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8Abuddy%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F/" data-id="cl95cpvup0000ugmj5yiydakw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-go语言协程调度原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2022-10-11T09:30:07.000Z" itemprop="datePublished">2022-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/">go语言协程调度原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>对于进程、线程，都是有内核进行调度，有CPU时间片的概念，进行抢占式调度。协程，又称微线程，纤程。英文名Coroutine。协程的调用有点类似子程序，如程序A调用了子程序B，子程序B调用了子程序C，当子程序C结束了返回子程序B继续执行之后的逻辑，当子程序B运行结束了返回程序A，直到程序A运行结束。但是和子程序相比，协程有<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8C%82%E8%B5%B7&spm=1001.2101.3001.7020">挂起</a>的概念，协程可以挂起跳转执行其他协程，合适的时机再跳转回来。</p>
<h2 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h2><ul>
<li>N:1模型，多个用户空间线程在1个内核空间线程上运行。优势是<strong>上下文切换非常快</strong>，因为这些线程都在内核态运行，但是无法利用多核系统的优点。</li>
<li>1:1模型，1个内核空间线程运行一个用户空间线程。这种充分利用了多核系统的优势但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。</li>
<li>M:N模型，内核空间开启多个内核线程，一个内核空间线程对应多个用户空间线程。效率非常高，但是管理复杂。</li>
</ul>
<h2 id="goroutine调度原理"><a href="#goroutine调度原理" class="headerlink" title="goroutine调度原理"></a>goroutine调度原理</h2><p>本质上goroutine就是协程，但是<strong>完全运行在用户态</strong>，借鉴了<strong>M:N</strong>模型。如下图</p>
<p><img src="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/b74346cf4f534e17831d0a58ecc4968f.png" alt="1.jpg"></p>
<p>相比其他语言，golang采用了<strong>MPG模型管理协程</strong>，更加高效，但是管理非常复杂。</p>
<ul>
<li>M：内核级线程</li>
<li>G：代表一个goroutine</li>
<li>P：Processor，处理器，用来管理和执行goroutine的。</li>
</ul>
<h3 id="G-M-P三者的关系与特点："><a href="#G-M-P三者的关系与特点：" class="headerlink" title="G-M-P三者的关系与特点："></a>G-M-P三者的关系与特点：</h3><ul>
<li>P的个数取决于设置的GOMAXPROCS，go新版本默认使用最大内核数，比如你有8核处理器，那么P的数量就是8</li>
<li>M的数量和P不一定匹配，可以设置很多M，M和P绑定后才可运行，多余的M处于休眠状态。</li>
<li>P包含一个LRQ（Local Run Queue）<strong>本地运行队列</strong>，这里面保存着P需要执行的协程G的队列</li>
<li>除了每个P自身保存的G的队列外，调度器还拥有一个<strong>全局的G队列GRQ</strong>（Global Run Queue），这个队列存储的是所有未分配的协程G。</li>
</ul>
<p>假设我们的主机是单核的，那么协程运行图是这样：<br><img src="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oOF44CB54ug546w5a6e,size_14,color_FFFFFF,t_70,g_se,x_16.png" alt="2.jpg"></p>
<p>红色部分表示挂起和休眠，黄色部分表示准备就绪等待运行，绿色部分表示正在运行。</p>
<p>主机是单核的所以只有一个处理器P，但是系统初始化了两个线程M0和M1，处理器P优先绑定了M0线程，M1进入休眠状态。</p>
<p>P的LRQ队列里有G1,G2,G3等待处理。P目前正在处理G0,全局等待队列GRQ里保存着G4,G5，表示这两个协程还未分配给P。</p>
<p>如果G0在短时间内处理完，P就会从LRQ中取出G1继续处理。并且将GRQ全局队列中的部分协程加入LRQ中。</p>
<p>如下图<br><img src="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oOF44CB54ug546w5a6e,size_12,color_FFFFFF,t_70,g_se,x_16.png" alt="3.jpg"></p>
<p>假设现在G1处理速度很慢，系统就会让M0线程休眠，挂起协程G1，唤醒线程M1进行处理其他的协程。这里M1会将M0未处理的协程取走处理。<br><img src="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oOF44CB54ug546w5a6e,size_11,color_FFFFFF,t_70,g_se,x_16.png" alt="4.jpg"></p>
<p>等到M1协程队列中所有协程处理完再次唤醒M0，或者M1处理某个协程时间较长被挂起，M0也会被唤醒。<br>上面的讨论是单核主机情况，如果是多核的，就会运行多个P和M，如下图<br><img src="/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oOF44CB54ug546w5a6e,size_14,color_FFFFFF,t_70,g_se,x_16-16654808508663.png" alt="5.jpg"></p>
<p>M0和M1分别运行在不同的内核线程中，M0处理G1,G2,G3，M1处理G4,G5,G6。</p>
<blockquote>
<p>有人会问，当M0处理完所有的协程，而M1还未处理完，系统会如何做呢？<br><strong>M0会取走M1的一半数量未处理的协程。</strong></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>golang协程设计非常优秀，一方面极大的利用了内核线程和处理器资源，另一方面每个处理器的LRQ队列的协程都处于用户态，这些协程的处理和挂起操作都是用户态的，协程切换开销非常小。相比其他语言的线程设计，更加轻量和高效。</p>
<p>转载于<a target="_blank" rel="noopener" href="https://blog.csdn.net/Ctrl_kun/article/details/123745555">https://blog.csdn.net/Ctrl_kun/article/details/123745555</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/10/11/go%E8%AF%AD%E8%A8%80%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" data-id="cl940cwql0000qcmjgzfj2qx0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">November 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/11/15/%E7%BC%96%E8%AF%91nuclei-qemu/">编译nuclei-qemu</a>
          </li>
        
          <li>
            <a href="/2022/11/03/spike%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A31/">spike相关理解1</a>
          </li>
        
          <li>
            <a href="/2022/11/02/qemu%E6%96%B0%E5%A2%9ESoc/">qemu新增Soc</a>
          </li>
        
          <li>
            <a href="/2022/10/28/rtos%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B/">rtos中断流程</a>
          </li>
        
          <li>
            <a href="/2022/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%8D%E5%9B%BE/">数据结构位图</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>