<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-c++线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/22/c++%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2022-08-22T01:27:42.000Z" itemprop="datePublished">2022-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/22/c++%E7%BA%BF%E7%A8%8B/">c++线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="mutex它包含以下三个部分："><a href="#mutex它包含以下三个部分：" class="headerlink" title="mutex它包含以下三个部分："></a>mutex它包含以下三个部分：</h2><p><strong>Mutex type</strong><br><strong>Locks：lock_guard， unique_lock</strong><br><strong>Functions：try_lock，lock</strong><br><strong>example：</strong><br>    mutex的实现也很简单，在进入临界区之前调用该变量（mtx）的lock函数，出临界区之前调用该变量的（mtx）的unlock函数。所以程序会连续输出50个’<em>‘或者连续输出50个’$’，而不会’</em>‘ ‘$’交替输出。</p>
<p>​    但是考虑这样一个问题，std::cout &lt;&lt; ‘\n’，这里发生异常会发生什么？抛出异常后，意味着mtx.unlock()不会被执行，即锁没有被释放，整个程序进入不了临界区，该程序往往会挂死。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>          <span class="comment">// std::mutex</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_block</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// critical section (exclusive access to std::cout signaled by locking mtx):</span></span><br><span class="line">  mtx.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123; std::cout &lt;&lt; c; &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">&#x27;*&#x27;</span>)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">th2</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">&#x27;$&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  th1.<span class="built_in">join</span>();</span><br><span class="line">  th2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard"></a>lock_guard</h2><p>​    在构造时，互斥对象被调用线程锁定，而在销毁时，互斥对象被解锁。它是最简单的锁，作为具有自动持续时间的对象特别有用，该持续时间一直持续到其上下文结束。这样，可以保证在抛出异常的情况下互斥对象已正确解锁。</p>
<p><strong>example</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lock_guard example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>          <span class="comment">// std::mutex, std::lock_guard</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>      <span class="comment">// std::logic_error</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_even</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; is even\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">throw</span> (std::<span class="built_in">logic_error</span>(<span class="string">&quot;not even&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lck</span> <span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="built_in">print_even</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::logic_error&amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[exception caught]\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = std::<span class="built_in">thread</span>(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h2><p>​    unique_lock基本用法和lock_guard一致，在构造函数和析构函数中进行锁操作，不同的地方在于它提供了非常多构造函数。</p>
<h2 id="condition-variable"><a href="#condition-variable" class="headerlink" title="condition_variable"></a>condition_variable</h2><p>​    条件变量是一个对象，可以阻塞线程，直到被通知恢复。当调用其等待功能之一时，它使用unique_lock（通过互斥锁）来锁定线程。该线程将保持阻塞状态，直到被另一个在同一个condition_variable对象上调用通知功能的线程唤醒为止。</p>
<h3 id="Wait-functions"><a href="#Wait-functions" class="headerlink" title="Wait functions"></a>Wait functions</h3><p><strong>wait</strong><br>Wait until notified (public member function )<br><strong>wait_for</strong><br>Wait for timeout or until notified (public member function )<br><strong>wait_until</strong><br>Wait until notified or time point (public member function )</p>
<h3 id="Notify-functions"><a href="#Notify-functions" class="headerlink" title="Notify functions"></a>Notify functions</h3><p><strong>notify_one</strong><br>Notify one (public member function )<br><strong>notify_all</strong><br>Notify all (public member function )<br><strong>example</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// condition_variable::notify_one</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>           <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>             <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span>              <span class="comment">// std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span> <span class="comment">// std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable produce,consume;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cargo = <span class="number">0</span>;     <span class="comment">// shared value by producers and consumers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (cargo==<span class="number">0</span>) consume.<span class="built_in">wait</span>(lck); <span class="comment">// 只有缓冲区非空时，消费者才执行</span></span><br><span class="line">  std::cout &lt;&lt; cargo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  cargo=<span class="number">0</span>;</span><br><span class="line">  produce.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span> <span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lck</span><span class="params">(mtx)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (cargo!=<span class="number">0</span>) produce.<span class="built_in">wait</span>(lck);  <span class="comment">//只有缓冲区为空时，生产者才执行</span></span><br><span class="line">  cargo = id;</span><br><span class="line">  consume.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::thread consumers[<span class="number">10</span>],producers[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 consumers and 10 producers:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">    consumers[i] = std::<span class="built_in">thread</span>(consumer);</span><br><span class="line">    producers[i] = std::<span class="built_in">thread</span>(producer,i+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// join them back:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i) &#123;</span><br><span class="line">    producers[i].<span class="built_in">join</span>();</span><br><span class="line">    consumers[i].<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="future"><a href="#future" class="headerlink" title="future"></a><strong>future</strong></h2><p>​    future的目标是充分利用CPU的并发性，它只能通过async，promise和package_task三种方式构造。future只能移动，不可复制，需要复制时可以使用shared_future，但通常不建议使用。调用future的get()时可能会发生阻塞，直到返回值ready。future有三种姿势的等待：</p>
<p><strong>wait()：</strong>一直等待直到得到返回值<br><strong>wait_for()：</strong>设定一个超时时间；<br><strong>wait_until()：</strong>等待到某个时间点。future有一特化版本future，返回值为空，即不返回任何值，因此仅能用于线程间通知，但却是最常用的future。</p>
<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>promise对象可以通过调用成员get_future将此共享状态与future对象关联。调用之后，两个对象共享相同的共享状态：</p>
<p><strong>promise：</strong>promise对象是异步提供者，在共享状态的时候设置一个值<br><strong>future：</strong>future对象是异步返回对象，可以检索共享状态的值，并在必要时等待其准备就绪<br><strong>example</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>     <span class="comment">// std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>         <span class="comment">// std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_int</span> <span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; fut)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> x = fut.<span class="built_in">get</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::promise&lt;<span class="type">int</span>&gt; prom;                      <span class="comment">// create promise</span></span><br><span class="line"></span><br><span class="line">  std::future&lt;<span class="type">int</span>&gt; fut = prom.<span class="built_in">get_future</span>();    <span class="comment">// engagement with future</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">th1</span> <span class="params">(print_int, std::ref(fut))</span></span>;  <span class="comment">// send future to new thread</span></span><br><span class="line"></span><br><span class="line">  prom.<span class="built_in">set_value</span> (<span class="number">10</span>);                         <span class="comment">// fulfill promise</span></span><br><span class="line">                                               <span class="comment">// (synchronizes with getting the future)</span></span><br><span class="line">  th1.<span class="built_in">join</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h2><p>很多情况下并不希望另起一个线程，因为线程是非常重要的资源。因此希望可以合理的管理线程资源，这就需要使用线程池。如何将future与线程池同时使用呢？这就需要采用package_task。package_task本质是将一个函数包装成一个future。这个task类似于std::function，有输入输出，大家可以将其认为是一个异步函数，但该异步函数并不负责执行，而是将其结果预置于一个future变量中，然后交给一个线程来实际执行，此时主线程便可以得到其返回值。</p>
<p><strong>example</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packaged_task example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>       <span class="comment">// std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       <span class="comment">// std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>       <span class="comment">// std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countdown</span> <span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=from; i!=to; --i) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Lift off!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> from-to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span>&gt; <span class="title">tsk</span> <span class="params">(countdown)</span></span>;   <span class="comment">// set up packaged_task</span></span><br><span class="line">  std::future&lt;<span class="type">int</span>&gt; ret = tsk.<span class="built_in">get_future</span>();            <span class="comment">// get future</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">th</span> <span class="params">(std::move(tsk),<span class="number">10</span>,<span class="number">0</span>)</span></span>;   <span class="comment">// spawn thread to count down from 10 to 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> value = ret.<span class="built_in">get</span>();                  <span class="comment">// wait for the task to finish and get result</span></span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;The countdown lasted for &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; seconds.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  th.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="async"><a href="#async" class="headerlink" title="async"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=async&spm=1001.2101.3001.7020">async</a></h2><p>有时某项工作很早就可以开始做（前置条件都已完备），而等待这件工作结果的任务在非常靠后的位置，这时候就需要async。换言之，如果可以尽早开始做一件事，就让其在后台运行即可，或快或慢都可以，只需在需要结果的时候运行完成就好。</p>
<p><strong>example</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async example</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>       <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span>         <span class="comment">// std::async, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a non-optimized way of checking for prime numbers:</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Calculating. Please, wait...\n&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;x; ++i) <span class="keyword">if</span> (x%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// call is_prime(313222313) asynchronously:</span></span><br><span class="line">  std::future&lt;<span class="type">bool</span>&gt; fut = std::<span class="built_in">async</span> (is_prime,<span class="number">313222313</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Checking whether 313222313 is prime.\n&quot;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> ret = fut.<span class="built_in">get</span>();      <span class="comment">// waits for is_prime to return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ret) std::cout &lt;&lt; <span class="string">&quot;It is prime!\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;It is not prime.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/22/c++%E7%BA%BF%E7%A8%8B/" data-id="cl7iuzc7500015smjhieha3ti" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-协程库学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/16/%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-08-16T06:54:19.000Z" itemprop="datePublished">2022-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/16/%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%AD%A6%E4%B9%A0/">协程库学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、协程概念"><a href="#1、协程概念" class="headerlink" title="1、协程概念"></a>1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8D%8F%E7%A8%8B&spm=1001.2101.3001.7020">协程</a>概念</h2><h3 id="1-1、进程与线程"><a href="#1-1、进程与线程" class="headerlink" title="1.1、进程与线程"></a>1.1、进程与线程</h3><p>​        <strong>进程是正在运行的程序的实例，进程拥有代码和打开的文件资源、数据资源、独立的内存空间。</strong></p>
<p>  <strong>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以有很多线程，每条线程并行执行不同的任务，他们共享进程所拥有的的资源，但线程拥有自己的栈空间。</strong><br>        <strong>对操作系统而言，线程是最小的执行单元，进程是最小的资源管理单元。无论是进程还是线程，都是被操作系统所管理的，当发生进程（或线程）的切换，操作系统需要执行”用户态–&gt;内核态–&gt;用户态“切换操作，将切换内容(上下文)保存到内存中（或内核栈）中。</strong></p>
<h3 id="1-2、协程"><a href="#1-2、协程" class="headerlink" title="1.2、协程"></a>1.2、协程</h3><p>  <strong>协程(Coroutines)是一种比线程更加轻量级的存在，协程可以理解为一个特殊的函数，这个函数可以在某个地方挂起去执行别的函数，并且可以返回挂起处继续执行。</strong></p>
<p>  <strong>一个线程内可以由多个协程来交互运行，但是多个协程的运行是绝对串行的，也就是说同一时刻只有一个协程在运行，当一个协程运行时，其它的协程必须被挂起。</strong></p>
<p>  <strong>协程不是被操作系管理的，而是是在用户态执行，完全由程序所控制的，根据程序员所写的调度策略，通过协作（而不是抢占）来进行切换的。协程的本质思想就是控制函数运行时的主动让出（yield）和恢复（resume）。每个协每个协程有自己的上下文，其切换由自己控制，当前协程切换到其它协程是由当前协程自己控制的。</strong></p>
<p><strong>协程函数与普通函数的区别：</strong></p>
<ul>
<li>普通函数执行完后会退出，并释放栈帧。</li>
<li>协程函数可以在运行过程中保存上下文(栈帧)，并主动切换到其它线程执行，还可以通过其它协程协作返回本函数继续执行</li>
</ul>
<p><strong>协程的特点总结如下：</strong></p>
<ul>
<li>用户态：协程是在用户态实现调度。</li>
<li>轻量级：协程不在内核调度，不需要内核态和用户态之间切换，使用开销比较小。</li>
<li>非抢占：协程是由用户自己实现调度，并且同一时间只能有一个协程在执行，协程主动交出CPU资源。</li>
</ul>
<h3 id="1-3-进程、线程、协程的对比"><a href="#1-3-进程、线程、协程的对比" class="headerlink" title="1.3 进程、线程、协程的对比"></a>1.3 进程、线程、协程的对比</h3><p>​        进程、线程都是由操作系统所管理的，存在用户态和内核态；而协程完全在用户态运行，自己实现调度。<br>​        一个进程可以包含多个线程，一个线程可以包含多个协程。<br>​        一个进程最少包含一个线程；但线程内可以不存在协程。<br>​        当CPU存在多个内核时，一个进程的多个线程可以并行执行；但是一个线程中的多个协程一定是串行执行的。<br>​        进程、线程、协程的切换都是上下文切换，区别如下：<br>​             进程的切换上下文：切换虚拟地址空间，切换内核栈和硬件上下文，切换内容保存在内存中。<br>​             线程的切换上下文：切换内核栈和硬件上下文，切换内容保存在内核栈中。<br>​             协程的切换上下文：切换硬件上下文，切换内容保存在用户态的变量（用户栈或堆）中。<br>​        进程、线程、协程的调度开销程度： 进程 &gt; 线程 &gt;&gt; 协程</p>
<h2 id="使用setjmp和longjmp模拟实现协程"><a href="#使用setjmp和longjmp模拟实现协程" class="headerlink" title="使用setjmp和longjmp模拟实现协程"></a>使用setjmp和longjmp模拟实现协程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> BOOL;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="comment">// 用来存储主程和协程的上下文的数据结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_Context_</span> &#123;</span><br><span class="line">    jmp_buf mainBuf; </span><br><span class="line">    jmp_buf coBuf;</span><br><span class="line">&#125;Context;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数2：func 需要的参数 </span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*pf)</span><span class="params">(<span class="type">void</span> *)</span></span>; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutine_function2</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutine_function1</span><span class="params">(<span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">start_coroutine</span><span class="params">(pf func, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">start_coroutine2</span><span class="params">(pf func, <span class="type">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">//上下文全局变量</span></span><br><span class="line">Context gCtx; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> resume() \</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (0 == setjmp(gCtx.mainBuf))\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">    longjmp(gCtx.coBuf,1);\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"><span class="comment">// 挂起 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yield()\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ( 0==setjmp(gCtx.coBuf))\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">        longjmp(gCtx.mainBuf,1);\</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> co_return()\</span></span><br><span class="line"><span class="meta">    longjmp(gCtx.coBuf,1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在协程中执行的函数 </span></span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutine_function1</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="number">100</span>)  <span class="comment">// 死循环 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n*** coroutine: working \n&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟耗时操作 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n***coroutine:suspend\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 让出 CPU </span></span><br><span class="line">            <span class="comment">// start_coroutine2(coroutine_function2,NULL);</span></span><br><span class="line">            <span class="built_in">yield</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">coroutine_function2</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(s&lt;<span class="number">400</span>)  <span class="comment">// 死循环 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n*** coroutine222222222: working \n&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟耗时操作 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n***coroutine22222222:suspend\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 让出 CPU </span></span><br><span class="line">            <span class="built_in">co_return</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s&lt;<span class="number">100</span>)  <span class="comment">// 死循环 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n*** coroutine: working \n&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟耗时操作 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n***coroutine:suspend\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 让出 CPU </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(s&lt;<span class="number">400</span>)  <span class="comment">// 死循环 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n*** coroutine222222222: working \n&quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟耗时操作 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            s++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n***coroutine22222222:suspend\n&quot;</span>);</span><br><span class="line">            <span class="comment">// 让出 CPU </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">start_coroutine</span><span class="params">(pf func, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 保存主程的跳转点 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">setjmp</span>(gCtx.mainBuf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(arg);<span class="comment">// 调用函数 </span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">start_coroutine2</span><span class="params">(pf func, <span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 保存主程的跳转点 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==<span class="built_in">setjmp</span>(gCtx.coBuf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">func</span>(arg);<span class="comment">// 调用函数 </span></span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">start_coroutine</span>(coroutine_function1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    _LARGE_INTEGER time_start;	<span class="comment">//开始时间</span></span><br><span class="line">	_LARGE_INTEGER time_over;	<span class="comment">//结束时间</span></span><br><span class="line">	<span class="type">double</span> dqFreq;		<span class="comment">//计时器频率</span></span><br><span class="line">	LARGE_INTEGER f;	<span class="comment">//计时器频率</span></span><br><span class="line">    <span class="built_in">QueryPerformanceFrequency</span>(&amp;f);</span><br><span class="line">	dqFreq=(<span class="type">double</span>)f.QuadPart;</span><br><span class="line">	<span class="built_in">QueryPerformanceCounter</span>(&amp;time_start);	<span class="comment">//计时开始</span></span><br><span class="line">    <span class="keyword">while</span>(n&lt;<span class="number">11</span>)<span class="comment">// 死循环 </span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== main: working \n&quot;</span>); </span><br><span class="line">    <span class="comment">// 模拟耗时操作 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n===main:suspend\n&quot;</span>);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n); </span><br><span class="line">    <span class="comment">// 放弃 CPU，让协程执行 </span></span><br><span class="line">    <span class="keyword">if</span>(s&lt;<span class="number">100</span>)<span class="built_in">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QueryPerformanceCounter</span>(&amp;time_over);	<span class="comment">//计时结束</span></span><br><span class="line">    <span class="type">double</span> run_time;</span><br><span class="line">	run_time=<span class="number">1000000</span>*(time_over.QuadPart-time_start.QuadPart)/dqFreq;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%fus\n&quot;</span>,run_time);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    n=<span class="number">0</span>;</span><br><span class="line">    s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">QueryPerformanceFrequency</span>(&amp;f);</span><br><span class="line">	dqFreq=(<span class="type">double</span>)f.QuadPart;</span><br><span class="line">	<span class="built_in">QueryPerformanceCounter</span>(&amp;time_start);	<span class="comment">//计时开始</span></span><br><span class="line">    <span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">while</span>(n&lt;<span class="number">11</span>)<span class="comment">// 死循环 </span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n=== main: working \n&quot;</span>); </span><br><span class="line">    <span class="comment">// 模拟耗时操作 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n===main:suspend\n&quot;</span>);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n); </span><br><span class="line">    <span class="comment">// 放弃 CPU，让协程执行 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QueryPerformanceCounter</span>(&amp;time_over);	<span class="comment">//计时结束</span></span><br><span class="line">    run_time=<span class="number">1000000</span>*(time_over.QuadPart-time_start.QuadPart)/dqFreq;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%fus\n&quot;</span>,run_time);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对比结果"><a href="#对比结果" class="headerlink" title="对比结果"></a>对比结果</h2><img src="/2022/08/16/%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%AD%A6%E4%B9%A0/image-20220816165258066.png" class="&#x3D;">

<img src="/2022/08/16/%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%AD%A6%E4%B9%A0/image-20220816165325317.png" class="&#x3D;">

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/16/%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%AD%A6%E4%B9%A0/" data-id="cl7iuzc7l000o5smjfe6da61j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leecode-28实现strStr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/" class="article-date">
  <time datetime="2022-08-12T06:36:07.000Z" itemprop="datePublished">2022-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/">leecode_28实现strStr</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-strstr/">28. 实现 strStr()</a></h2><p>实现 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p>
<p><strong>说明：</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>​    实现kmp算法，kmp与朴素暴力方法不同的地方，原串的指针不回溯，而要比较的串，找相同的最长前缀和后缀，匹配失败后，指针回到前缀的后一位。</p>
<p>​    构建next数组：</p>
<pre><code>接下来，我们看看 next 数组是如何在 O(m)O(m) 的复杂度内被预处理出来的。
</code></pre>
<p>假设有匹配串 aaabbab，我们来看看对应的 next 是如何被构建出来的。</p>
<img src="/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/image-20220812155831188.png" class>

<img src="/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/image-20220812155913250.png" class>

<img src="/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/image-20220812155923413.png" class>

<img src="/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/image-20220812155938839.png" class>

<p>这就是整个 next 数组的构建过程，时空复杂度均为 O(m)O(m)。</p>
<p>至此整个 KMP 匹配过程复杂度是 O(m + n)O(m+n) 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; needle[i]!=needle[j]) i=next[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span>(needle[i]==needle[j]) i++;</span><br><span class="line">	next[j]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总的KMP源代码："><a href="#总的KMP源代码：" class="headerlink" title="总的KMP源代码："></a>总的KMP源代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n= haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(m+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">1</span>;i&lt;m,j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &amp;&amp; needle[i]!=needle[j]) i=next[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(needle[i]==needle[j]) i++; </span><br><span class="line">            next[j]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            cout&lt;&lt;next[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/12/leecode-28%E5%AE%9E%E7%8E%B0strStr/" data-id="cl7iuzc7f000d5smjds9z6ifc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leecode-1282用户分组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/12/leecode-1282%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/" class="article-date">
  <time datetime="2022-08-12T05:38:26.000Z" itemprop="datePublished">2022-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/12/leecode-1282%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/">leecode_1282用户分组</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1282-用户分组"><a href="#1282-用户分组" class="headerlink" title="1282. 用户分组"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/">1282. 用户分组</a></h2><p>有 <code>n</code> 个人被分成数量未知的组。每个人都被标记为一个从 <code>0</code> 到 <code>n - 1</code> 的<strong>唯一ID</strong> 。</p>
<p>给定一个整数数组 <code>groupSizes</code> ，其中 <code>groupSizes[i]</code> 是第 <code>i</code> 个人所在的组的大小。例如，如果 <code>groupSizes[1] = 3</code> ，则第 <code>1</code> 个人必须位于大小为 <code>3</code> 的组中。</p>
<p>返回一个组列表，使每个人 <code>i</code> 都在一个大小为 <em><code>groupSizes[i]</code></em> 的组中。</p>
<p>每个人应该 <strong>恰好只</strong> 出现在 <strong>一个组</strong> 中，并且每个人必须在一个组中。如果有多个答案，返回其中 <strong>任何</strong> 一个。可以 <strong>保证</strong> 给定输入 <strong>至少有一个</strong> 有效的解。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：groupSizes = [3,3,3,3,3,1,3]</span><br><span class="line">输出：[[5],[0,1,2],[3,4,6]]</span><br><span class="line">解释：</span><br><span class="line">第一组是 [5]，大小为 1，groupSizes[5] = 1。</span><br><span class="line">第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。</span><br><span class="line">第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。 </span><br><span class="line">其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：groupSizes = [2,1,3,3,3,2]</span><br><span class="line">输出：[[1],[0,5],[2,3,4]]</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>​    采用哈希法，将size一样的数存入一个表中，最后在按size分出一个个组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">groupThePeople</span>(vector&lt;<span class="type">int</span>&gt;&amp; groupSizes) &#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;groupSizes.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> size = groupSizes[i];</span><br><span class="line">            map[size].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp;[size,people]:map)&#123;</span><br><span class="line">            <span class="type">int</span> groupSize = people.<span class="built_in">size</span>()/size;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt; groupSize;i++)&#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; tmp;              </span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                   tmp.<span class="built_in">push_back</span>(people[count++]);</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/12/leecode-1282%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/" data-id="cl7iuzc7b00075smje8svedd1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leecode-1417" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/11/leecode-1417/" class="article-date">
  <time datetime="2022-08-11T08:33:41.000Z" itemprop="datePublished">2022-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/11/leecode-1417/">leecode_1417</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1417-重新格式化字符串"><a href="#1417-重新格式化字符串" class="headerlink" title="1417. 重新格式化字符串"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reformat-the-string/">1417. 重新格式化字符串</a></h2><p>给你一个混合了数字和字母的字符串 <code>s</code>，其中的字母均为小写英文字母。</p>
<p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p>
<p>请你返回 <strong>重新格式化后</strong> 的字符串；如果无法按要求重新格式化，则返回一个 <strong>空字符串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a0b1c2&quot;</span><br><span class="line">输出：&quot;0a1b2c&quot;</span><br><span class="line">解释：&quot;0a1b2c&quot; 中任意两个相邻字符的类型都不同。 &quot;a0b1c2&quot;, &quot;0a1b2c&quot;, &quot;0c2a1b&quot; 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;leetcode&quot; 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;1229857369&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：&quot;1229857369&quot; 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;covid2019&quot;</span><br><span class="line">输出：&quot;c2o0v1i9d&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab123&quot;</span><br><span class="line">输出：&quot;1a2b3&quot;</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>​    将字符串中分为字母和数字，然后重新拼接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       </span><br><span class="line">    <span class="function">string <span class="title">reformat</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> s1[<span class="number">1000</span>];  <span class="comment">//数字</span></span><br><span class="line">        <span class="type">char</span> s2[<span class="number">1000</span>];  <span class="comment">//字母</span></span><br><span class="line">        string s3;</span><br><span class="line">        <span class="type">int</span> count1=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res1=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                s1[count1++]=s[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s2[count2++]=s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(count2-count1)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count1&lt;count2)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                        s3+=s2[res2++];</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        s3+=s1[res1++];</span><br><span class="line">                        flag=<span class="number">0</span>;</span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                        s3+=s1[res1++];</span><br><span class="line">                        flag=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        s3+=s2[res2++];</span><br><span class="line">                        flag=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">if</span>(count1&lt;count2) s3[s.<span class="built_in">size</span>()<span class="number">-1</span>]=s2[count2<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(count1&gt;count2) s3[s.<span class="built_in">size</span>()<span class="number">-1</span>]=s1[count1<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">return</span> s3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/11/leecode-1417/" data-id="cl7iuzc7b00085smjh4xj4bd8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-编译原理学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time datetime="2022-08-11T05:10:54.000Z" itemprop="datePublished">2022-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/">编译原理学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="编译原理的学习"><a href="#编译原理的学习" class="headerlink" title="编译原理的学习"></a>编译原理的学习</h2><p>机器语言 ， 汇编语言， 高级语言</p>
<p>汇编语言 汇编成 机器语言</p>
<p>高级语言 编译成 汇编语言或机器语言</p>
<h3 id="1、词法语法分析基本概念"><a href="#1、词法语法分析基本概念" class="headerlink" title="1、词法语法分析基本概念"></a>1、词法语法分析基本概念</h3><p><strong>文法G=（Vt,Vn,P,S）</strong> 其中Vt是终结符，Vn是非终结符，P是产生式，S是开始符</p>
<p><strong>终结符：1、字母表中排在前面的小写字母如a，b，c</strong></p>
<p><strong>2、运算符 +  - 等</strong></p>
<p><strong>3、标点符号 如括号或逗号</strong></p>
<p><strong>4、数字0，1，2。。。9</strong></p>
<p><strong>5、粗体字符串如 id if</strong></p>
<p><strong>非终结符： 1、字母表中排在前面的大写字母，如A，B，C</strong></p>
<p><strong>2、字母S。通常表示开始符号</strong></p>
<p><strong>3、小写、斜体的名字 如<em>expr</em>、<em>stmt</em></strong></p>
<p><strong>4、代表程序构造的大写字母 如E（表达式）、T（项）、和F（因子）</strong></p>
<p><strong>文法符号： 字母表中排在后面的大写字母X，Y，Z</strong></p>
<p><strong>终结符号串：字母表中排在后面的小写字母，u，v，。。。。，z</strong></p>
<p><strong>文法符号串：小写希腊字母</strong></p>
<p><strong>句型和句子</strong>: S =&gt; a, a中含有终结符和非终结符或者是空串，则a是句型，句子就是不包含非终结符的句型</p>
<p><strong>0型文法：短语结构文法 ，产生式的左边至少有一个非终结符</strong></p>
<p><strong>1型文法：上下文有关文法，|a|&lt;=|b|,不产生空产生式</strong></p>
<p><strong>2型文法：上下文无关文法，产生式左边必须是一个非终结符</strong></p>
<p><strong>3型文法：正则文法</strong></p>
<p><strong>右线型：A-&gt;w 或 A -&gt; wB</strong></p>
<p><strong>左线型：A-&gt;w 或 A -&gt;Bw</strong></p>
<p><strong>有穷自动机</strong>：<strong>最长字串前缀匹配原则</strong></p>
<p><strong>正则文法</strong> &lt;=&gt; <strong>正则表达式</strong> &lt;=&gt; <strong>有穷自动机</strong> </p>
<p><strong>消除左递归</strong></p>
<img src="/2022/08/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/image-20220812165234760.png" class>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/11/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/" data-id="cl7iuzc7q000x5smjhycffdvl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leecode-640求解方程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/10/leecode-640%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/" class="article-date">
  <time datetime="2022-08-10T08:42:56.000Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/10/leecode-640%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/">leecode#640求解方程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="640-求解方程"><a href="#640-求解方程" class="headerlink" title="640. 求解方程"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/solve-the-equation/">640. 求解方程</a></h2><p><strong>求解一个给定的方程，将<code>x</code>以字符串 <code>&quot;x=#value&quot;</code> 的形式返回。该方程仅包含 <code>&#39;+&#39;</code> ， <code>&#39;-&#39;</code> 操作，变量 <code>x</code> 和其对应系数。</strong></p>
<p><strong>如果方程没有解，请返回 <code>&quot;No solution&quot;</code> 。如果方程有无限解，则返回 <code>“Infinite solutions”</code> 。</strong></p>
<p><strong>题目保证，如果方程中只有一个解，则 ‘x’ 的值是一个整数。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: equation = &quot;x+5-3+x=6+x-2&quot;</span><br><span class="line">输出: &quot;x=2&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: equation = &quot;x=x&quot;</span><br><span class="line">输出: &quot;Infinite solutions&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: equation = &quot;2x=x&quot;</span><br><span class="line">输出: &quot;x=0&quot;</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>​    <strong>将等式右边的数据和x移动到等式左边，等式中的项的符号用sign1表示，默认为1.则等式右边的符号默认为-1，用sign2来表示+或-，最后得到x项和常数项。将他们的系数相除就能得到结果。</strong></p>
<p>​    <strong>其中要特别注意0x=0这种情况！！！！</strong> </p>
<p>​    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">solveEquation</span><span class="params">(string equation)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> factor =<span class="number">0</span> ,sign1=<span class="number">1</span>; </span><br><span class="line">        <span class="type">int</span> n=equation.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> val=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equation[index]==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">                sign1=<span class="number">-1</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> sign2=sign1,number=<span class="number">0</span>;</span><br><span class="line">            <span class="type">bool</span> valid=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(equation[index]==<span class="string">&#x27;-&#x27;</span>||equation[index]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                sign2=(equation[index]==<span class="string">&#x27;-&#x27;</span>)?-sign1:sign1;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(index&lt;n&amp;&amp;<span class="built_in">isdigit</span>(equation[index]))&#123; <span class="comment">//从字符串中得到具体数字</span></span><br><span class="line">                number = number*<span class="number">10</span>+(equation[index]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                index++;</span><br><span class="line">                valid=<span class="literal">true</span>;<span class="comment">//用来判断是数字还是x</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;n&amp;&amp;equation[index]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">                factor+=valid?sign2*number:sign2;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                val+=sign2*number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (factor == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> val == <span class="number">0</span> ? <span class="string">&quot;Infinite solutions&quot;</span> : <span class="string">&quot;No solution&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;x=&quot;</span>) + <span class="built_in">to_string</span>(-val / factor);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/leecode-640%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/" data-id="cl7iuzc7g000f5smjdjvh7v9l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leecode-636" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/10/leecode-636/" class="article-date">
  <time datetime="2022-08-10T08:41:48.000Z" itemprop="datePublished">2022-08-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/10/leecode-636/">leecode#636</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="636-函数的独占时间"><a href="#636-函数的独占时间" class="headerlink" title="636. 函数的独占时间"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/exclusive-time-of-functions/">636. 函数的独占时间</a></h2><p>有一个 <strong>单线程</strong> CPU 正在运行一个含有 <code>n</code> 道函数的程序。每道函数都有一个位于 <code>0</code> 和 <code>n-1</code> 之间的唯一标识符。</p>
<p>函数调用 <strong>存储在一个 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B0%83%E7%94%A8%E6%A0%88/22718047?fr=aladdin">调用栈</a> 上</strong> ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 <strong>当前正在执行的函数</strong> 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。</p>
<p>给你一个由日志组成的列表 <code>logs</code> ，其中 <code>logs[i]</code> 表示第 <code>i</code> 条日志消息，该消息是一个按 <code>&quot;&#123;function_id&#125;:&#123;&quot;start&quot; | &quot;end&quot;&#125;:&#123;timestamp&#125;&quot;</code> 进行格式化的字符串。例如，<code>&quot;0:start:3&quot;</code> 意味着标识符为 <code>0</code> 的函数调用在时间戳 <code>3</code> 的 <strong>起始开始执行</strong> ；而 <code>&quot;1:end:2&quot;</code> 意味着标识符为 <code>1</code> 的函数调用在时间戳 <code>2</code> 的 <strong>末尾结束执行</strong>。注意，函数可以 <strong>调用多次，可能存在递归调用</strong> 。</p>
<p>函数的 <strong>独占时间</strong> 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 <code>2</code> 单位时间，另一次调用执行 <code>1</code> 单位时间，那么该函数的 <strong>独占时间</strong> 为 <code>2 + 1 = 3</code> 。</p>
<p>以数组形式返回每个函数的 <strong>独占时间</strong> ，其中第 <code>i</code> 个下标对应的值表示标识符 <code>i</code> 的函数的独占时间。</p>
<p><strong>示例 1：</strong></p>
<img src="/2022/08/10/leecode-636/diag1b.png" class>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;1:start:2&quot;,&quot;1:end:5&quot;,&quot;0:end:6&quot;]</span><br><span class="line">输出：[3,4]</span><br><span class="line">解释：</span><br><span class="line">函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 </span><br><span class="line">函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 </span><br><span class="line">函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 </span><br><span class="line">所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;0:start:6&quot;,&quot;0:end:6&quot;,&quot;0:end:7&quot;]</span><br><span class="line">输出：[8]</span><br><span class="line">解释：</span><br><span class="line">函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。</span><br><span class="line">函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。</span><br><span class="line">函数 0（初始调用）恢复执行，并立刻再次调用它自身。</span><br><span class="line">函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。</span><br><span class="line">函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。</span><br><span class="line">所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:6&quot;,&quot;1:end:6&quot;,&quot;0:end:7&quot;]</span><br><span class="line">输出：[7,1]</span><br><span class="line">解释：</span><br><span class="line">函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。</span><br><span class="line">函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。</span><br><span class="line">函数 0（初始调用）恢复执行，并立刻调用函数 1 。</span><br><span class="line">函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。</span><br><span class="line">函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。</span><br><span class="line">所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, logs = [&quot;0:start:0&quot;,&quot;0:start:2&quot;,&quot;0:end:5&quot;,&quot;1:start:7&quot;,&quot;1:end:7&quot;,&quot;0:end:8&quot;]</span><br><span class="line">输出：[8,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1, logs = [&quot;0:start:0&quot;,&quot;0:end:0&quot;]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>​    使用栈的思维，当一个程序被调用的时候，他就入栈，当程序结束的时候，就出栈。</p>
<p>​    总共有两条原则：</p>
<p>​    <strong>当下一个程序开始执行时，当前程序应该暂停运行，计算前的执行时间，然后将该函数入栈</strong></p>
<p>​    <strong>但一个函数结束时，必定栈顶必定对应于他的开始，将栈顶弹出，计算执行时间，此时如果有暂停的函数，则继续执行</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">exclusiveTime</span><span class="params">(<span class="type">int</span> n, vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; log:logs)&#123;</span><br><span class="line">            <span class="type">char</span> type[<span class="number">10</span>];</span><br><span class="line">            <span class="type">int</span> idx,timestamp;</span><br><span class="line">            <span class="built_in">sscanf</span>(log.<span class="built_in">c_str</span>(), <span class="string">&quot;%d:%[^:]:%d&quot;</span>, &amp;idx, type, &amp;timestamp);</span><br><span class="line">            <span class="keyword">if</span>(type[<span class="number">0</span>]==<span class="string">&#x27;s&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    res[st.<span class="built_in">top</span>().first] += timestamp - st.<span class="built_in">top</span>().second;</span><br><span class="line">                    st.<span class="built_in">top</span>().second = timestamp;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">emplace</span>(idx, timestamp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">auto</span> t=st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                res[t.first]+=timestamp-t.second+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    st.<span class="built_in">top</span>().second = timestamp+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/10/leecode-636/" data-id="cl7iuzc7g000e5smj916r0w90" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-搭建riscv环境" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/09/%E6%90%AD%E5%BB%BAriscv%E7%8E%AF%E5%A2%83/" class="article-date">
  <time datetime="2022-08-09T02:20:43.000Z" itemprop="datePublished">2022-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/09/%E6%90%AD%E5%BB%BAriscv%E7%8E%AF%E5%A2%83/">搭建riscv环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="搭建RISC-V-RISCV-gnu-toolchain的安装（勿使用wsl系统，使用-虚拟机安装ubuntu）"><a href="#搭建RISC-V-RISCV-gnu-toolchain的安装（勿使用wsl系统，使用-虚拟机安装ubuntu）" class="headerlink" title="搭建RISC-V RISCV-gnu-toolchain的安装（勿使用wsl系统，使用 虚拟机安装ubuntu）"></a>搭建RISC-V RISCV-gnu-toolchain的安装（勿使用wsl系统，使用 虚拟机安装ubuntu）</h2><h3 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirror.iscas.ac.cn/plct/riscv-gnu-toolchain.20220725.tar.bz2 </span><br></pre></td></tr></table></figure>

<p><strong>解压</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvf riscv-gnu-toolchain</span><br></pre></td></tr></table></figure>

<p>一共大概会花一小时</p>
<h3 id="二、配置安装环境（依赖）"><a href="#二、配置安装环境（依赖）" class="headerlink" title="二、配置安装环境（依赖）"></a>二、配置安装环境（依赖）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev</span><br></pre></td></tr></table></figure>

<h2 id="三、再编译安装riscv-gnu-toolchain"><a href="#三、再编译安装riscv-gnu-toolchain" class="headerlink" title="三、再编译安装riscv-gnu-toolchain"></a>三、再编译安装riscv-gnu-toolchain</h2><p>进入到riscv-gnu-toolchain下执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd riscv-gnu-toolchian</span><br><span class="line">./configure --prefix=/opt/riscv64</span><br><span class="line">sudo make</span><br></pre></td></tr></table></figure>

<p><strong>最后添加环境变量</strong>：（<strong>才能在任何路径下使用该应用</strong>/<strong>软件</strong>）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入~/.bashrc</span></span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">然后添加语句</span></span><br><span class="line">export RISCV=/opt/riscv64</span><br><span class="line">export PATH=&quot;$RISCV/bin:$PATH&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">保存并更新环境</span></span><br><span class="line">:wq </span><br><span class="line">source ~/.bashrc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc --version</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/09/%E6%90%AD%E5%BB%BAriscv%E7%8E%AF%E5%A2%83/" data-id="cl7iuzc7m000r5smj91fmdqvp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leecode-25K个一组链表翻转" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/08/leecode-25K%E4%B8%AA%E4%B8%80%E7%BB%84%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/" class="article-date">
  <time datetime="2022-08-08T08:40:43.000Z" itemprop="datePublished">2022-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/08/leecode-25K%E4%B8%AA%E4%B8%80%E7%BB%84%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/">leecode#25K个一组链表翻转</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p><strong>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</strong></p>
<p><strong><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</strong></p>
<p><strong>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中的节点数目为 <code>n</code></li>
<li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>​    首先拆分成连个问题： 链表翻转，链表分段</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">       ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">       ListNode *curr=head;</span><br><span class="line">       <span class="keyword">while</span>(curr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">           ListNode *next = curr-&gt;next;</span><br><span class="line">           curr-&gt;next= pre;</span><br><span class="line">           pre = curr;</span><br><span class="line">           curr = next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>​    其次需要两个指针，其中start为每一段的头指针，end每次在翻转前要遍历到最后，若没有k长则不需要翻转，若有则end-&gt;next指向下一段的头指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">       ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">       dummy-&gt;next = head;</span><br><span class="line">       <span class="comment">/*pre指向每次要翻转的结点的上一个结点 */</span></span><br><span class="line">    	ListNode *pre = dummy;</span><br><span class="line">       ListNode *end = pre;</span><br><span class="line">       <span class="keyword">while</span>(end-&gt;next)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k&amp;&amp;end!=<span class="literal">nullptr</span>;i++) end=end-&gt;next;</span><br><span class="line">           <span class="keyword">if</span>(end==<span class="literal">nullptr</span>) <span class="keyword">break</span>;</span><br><span class="line">           <span class="comment">/*start 每次指向要翻转的结点*/</span></span><br><span class="line">           ListNode *start = pre-&gt;next;</span><br><span class="line">           ListNode *next = end-&gt;next;</span><br><span class="line">           end-&gt;next = <span class="literal">nullptr</span>; </span><br><span class="line">           pre-&gt;next=<span class="built_in">reverse</span>(start);</span><br><span class="line">           start-&gt;next = next;</span><br><span class="line">           pre = start;</span><br><span class="line">           end = pre;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/08/08/leecode-25K%E4%B8%AA%E4%B8%80%E7%BB%84%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC/" data-id="cl7iuzc7f000c5smj9jjg2xpu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/15/rvcc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014/">rvcc学习笔记14</a>
          </li>
        
          <li>
            <a href="/2022/09/14/rvcc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013/">rvcc学习笔记13</a>
          </li>
        
          <li>
            <a href="/2022/09/14/rvcc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012/">rvcc学习笔记12</a>
          </li>
        
          <li>
            <a href="/2022/09/13/leecode-670/">leecode#670</a>
          </li>
        
          <li>
            <a href="/2022/09/13/%E6%B1%87%E7%BC%96%E7%9B%B8%E5%85%B3/">汇编相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>